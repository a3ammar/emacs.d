#+TITLE: My Emacs Configuration As an Org File

This is is inspired by [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha's]] Emacs configuration.

* Emacs Initialization
Setup the necessary things that should happen before anything else.

** Initialize Packages
Setup ELPA package sources and initialize =package.el=.

#+BEGIN_SRC emacs-lisp
(setq package--init-file-ensured t)

(package-initialize)

(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
(add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/") t)

(unless package-archive-contents
  (package-refresh-contents))
#+END_SRC

** Setup use-package
Read about [[https://github.com/jwiegley/use-package][use-package]].

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-install 'use-package))

(setq use-package-verbose t
      use-package-always-ensure t)

(eval-when-compile
  (require 'use-package))
#+END_SRC

** Setup Automatic Compilation
This will help [[https://github.com/tarsius/auto-compile][auto compile]] each library we load.

#+BEGIN_SRC emacs-lisp
(setq load-prefer-newer t)

(use-package auto-compile
  :init
  (setq auto-compile-display-buffer nil
        auto-compile-mode-line-counter t)

  (auto-compile-on-load-mode))
#+END_SRC

** Depend on Dash and S Libraries
This whole configuration depends on [[https://github.com/magnars/dash.el][dash.el]] and [[https://github.com/magnars/s.el][s.el]] so load them early.

#+BEGIN_SRC emacs-lisp
(use-package s)
(use-package dash :config (dash-enable-font-lock))
#+END_SRC

** Pin Depencies to stable versions
Avoid breaking packages by pinning those dependencies to their stable version.

#+BEGIN_SRC emacs-lisp
(-each '((diminish . "melpa-stable")
         (epl . "melpa-stable")
         (f . "melpa-stable")
         (git-commit . "melpa-stable")
         (hydra . "melpa-stable")
         (inflections . "melpa-stable")
         (logito . "melpa-stable")
         (makey . "melpa-stable")
         (names . "melpa-stable")
         (packed . "melpa-stable")
         (pcache . "melpa-stable")
         (pkg-info . "melpa-stable")
         (popup . "melpa-stable")
         (rich-minority . "melpa-stable")
         (s . "melpa-stable")
         (use-package . "melpa-stable")
         (with-editor . "melpa-stable"))
  (lambda (package)
    (add-to-list 'package-pinned-packages package)))
#+END_SRC

** Are We on OS X Helper
This function will help us determine if we are on OS X

#+BEGIN_SRC emacs-lisp
(defun on-osx-p ()
  (eq system-type 'darwin))
#+END_SRC




* Defaults Configuration
Change the default Emacs configuration, from default variables to keybindings.

** Personal Information
Let Emacs know who is using it.

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Ammar Alammar"
      user-mail-address "ammar@ammasa.net")
#+END_SRC

** Better Emacs Defaults
Emacs default configuration are awful, lets fix it.

If you want the meaning of these variables move the point to the desired variable
and press =C-h v=.

#+BEGIN_SRC emacs-lisp
(setq comment-style 'multi-line
      create-lockfiles nil
      confirm-kill-emacs 'y-or-n-p
      delete-by-moving-to-trash t
      echo-keystrokes 0.1
      font-lock-maximum-decoration t
      gc-cons-threshold (* 50 1024 1024)
      hscroll-step 1
      inhibit-startup-echo-area-message t
      inhibit-startup-message t
      large-file-warning-threshold nil
      mouse-wheel-flip-direction t
      mouse-wheel-progressive-speed nil
      mouse-wheel-scroll-amount '(0.01)
      mouse-wheel-tilt-scroll t
      ring-bell-function 'ignore
      scroll-conservatively 10
      shift-select-mode nil
      transient-mark-mode t
      truncate-partial-width-windows nil
      uniquify-buffer-name-style 'forward)

(setq-default comment-column 0)
#+END_SRC

** Enable Every Disabled Command
I just don't want to be prompted about disabled commands.

#+BEGIN_SRC emacs-lisp
(setq disabled-command-function nil)
#+END_SRC

** UTF-8 Everywhere Please
UTF-8 everything. Taken from [[http://stackoverflow.com/questions/2901541/which-coding-system-should-i-use-in-emacs][this answer]].

#+BEGIN_SRC emacs-lisp
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-language-environment 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(setq locale-coding-system 'utf-8)
#+END_SRC

** Set the Default Language Environment Variable
This is important to set early on so Emacs initializes with the correct language.

#+BEGIN_SRC emacs-lisp
(setenv "LANG" "en_US.UTF-8")
#+END_SRC

** Set the Scratch Buffer's Default Mode
#+BEGIN_SRC emacs-lisp
(setq initial-major-mode 'org-mode)
#+END_SRC

And protect it from accidental killing

#+BEGIN_SRC emacs-lisp
(with-current-buffer "*scratch*"
  (emacs-lock-mode 'kill))
#+END_SRC


** Start Emacs Server
#+BEGIN_SRC emacs-lisp
(when window-system (add-hook 'after-init-hook 'server-start t))
#+END_SRC

** Setup Default Path Constants
I prefer to have all Emacs history and temporary files under one directory (=~/emacs.d/history/=).

#+BEGIN_SRC emacs-lisp
(defvar my/history-dir (expand-file-name "history/" user-emacs-directory))
(defvar my/elisp-dir (expand-file-name "elisp/" user-emacs-directory))
#+END_SRC

** Add My Custom Libraries to Emacs Load Path
Recursivly add every library in =my/elisp-dir= to Emacs load path.

#+BEGIN_SRC emacs-lisp
(let ((default-directory my/elisp-dir))
  (normal-top-level-add-to-load-path '("."))
  (normal-top-level-add-subdirs-to-load-path))
#+END_SRC

** File Backups
Emacs by default saves backup files in the current directory, cluttering your
directory with files ending with =~=. This stashes them away in
=my/history-dir=.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist `(("." . ,(concat my/history-dir "backups"))))
#+END_SRC

And save lots.

#+BEGIN_SRC emacs-lisp
(setq delete-old-versions -1
      version-control t
      vc-make-backup-files t
      auto-save-file-name-transforms `((".*" ,(concat my/history-dir "auto-save-list/") t))
      auto-save-list-file-prefix (concat my/history-dir "auto-save-list/saves-"))
#+END_SRC

Make =save-buffer= always creates a backup by passing two =C-u=

#+BEGIN_SRC emacs-lisp
(defun my/save-buffer ()
  (interactive)
  (let ((current-prefix-arg '(4 4)))
    (if (string= (buffer-name (current-buffer)) "*scratch*")
        (message "Skipping saving *scratch* buffer")
      (call-interactively 'save-buffer))))

(bind-key "C-x C-s" 'my/save-buffer)
#+END_SRC

** Session History
This saves our position in files other things between Emacs sessions.

#+BEGIN_SRC emacs-lisp
(setq history-length 1000
      history-delete-duplicates t
      savehist-save-minibuffer-history t
      savehist-file (concat my/history-dir "savehist")
      save-place-file (concat my/history-dir "saveplace")
      savehist-additional-variables '(kill-ring
                                      global-mark-ring
                                      search-ring
                                      regex-search-ring
                                      extended-command-history))

(savehist-mode)
#+END_SRC

** Visited Files History
Remembers visited files names.

#+BEGIN_SRC emacs-lisp
(setq recentf-auto-cleanup 'mode
      recentf-max-saved-items 100
      recentf-save-file (concat my/history-dir "recentf"))

(recentf-mode)
#+END_SRC

** Bookmarks File
#+BEGIN_SRC emacs-lisp
(setq bookmark-default-file (concat my/history-dir "bookmarks"))
#+END_SRC

** Miscellaneous  History Files
These files show up in my =.emacs.d=, so lets stick them in the history file.

#+BEGIN_SRC emacs-lisp
(setq image-dired-dir (concat my/history-dir "image-dired/"))
#+END_SRC

** Load Customization File
Prevent Emacs from appending Easy Customization to our configuration file.

#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "customization.el" user-emacs-directory))

(load custom-file 'noerror)
#+END_SRC

** Prevent Confirmation Prompt When Killing Process Buffers
When you kill a buffer that has a process attached to it, a repl for example, Emacs will
ask fro confirmation if you really want to kill the buffer. This will disable that.

#+BEGIN_SRC emacs-lisp
(setq kill-buffer-query-functions
      (-remove-item 'process-kill-buffer-query-function kill-buffer-query-functions))
#+END_SRC

** Use Spaces for Indentation
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

** Set the Default Indentation Size
#+BEGIN_SRC emacs-lisp
(setq-default tab-width 2)
#+END_SRC

** Set the Default Fill Column
For wrapping text with =M-q= and auto-fill-mode

#+BEGIN_SRC emacs-lisp
(setq-default fill-column 90)
#+END_SRC

** Ensure Edited Files End with a New Line
In UNIX, a healthy file always ends with a new line.

#+BEGIN_SRC emacs-lisp
(setq-default require-final-newline t)
#+END_SRC

** Show the Current Column Position
Show the current column position in the mode line.

#+BEGIN_SRC emacs-lisp
(column-number-mode)
#+END_SRC

** Enable Subword Mode
Subword mode makes commands like =forward-word= and =backward-words= be aware of
CamelCase words so they stop right after the =l= and before the capital =C=.

#+BEGIN_SRC emacs-lisp
(global-subword-mode)
#+END_SRC

** Sentence End
Sentence end with only one space.

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

** Replace selection on typing
By default Emacs doesn't change the content of the selection when you type or yank something. This fixes that.

#+BEGIN_SRC emacs-lisp
(delete-selection-mode)
#+END_SRC

** Use =y= And =n= for Confirmation
No one likes to type a full =yes=, =y= is enough as a confirmation.

#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Automatically Extract Compressed Files
Allow Emacs to extract compressed files and also compress them back after saving the file.

#+BEGIN_SRC emacs-lisp
(auto-compression-mode)
#+END_SRC

** Automatically Reload Files With Outside Changes
Whenever a file opened by Emacs changed by an external program, this mode
automatically reload the file

#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode)
#+END_SRC

Set a better keybinding for =revert-buffer= No one likes =s-u=

#+BEGIN_SRC emacs-lisp
(bind-key "C-x t r" 'revert-buffer)
#+END_SRC

** Automatically Clean Files on Save
Clean a file on save according to various rules, like trailing whitespaces or empty
lines, etc.

#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :config
  (setq whitespace-action '(auto-cleanup)
        whitespace-style '(trailing
                           lines
                           empty
                           space-before-tab
                           indentation
                           space-after-tab))

  (global-whitespace-mode))
#+END_SRC

** Set the Cursor Look
I like my cursor to be a thin line.

#+BEGIN_SRC emacs-lisp
(setq-default cursor-type 'bar)
#+END_SRC

** Add Padding to the Window Edges
Add a one pixel padding to the edges of Emacs window.

#+BEGIN_SRC emacs-lisp
(set-fringe-mode 1)
#+END_SRC

** A Better Mode Line
[[https://github.com/Malabarba/smart-mode-line][Smart Mode Line]] makes Emacs mode line beautiful.

#+BEGIN_SRC emacs-lisp
(use-package smart-mode-line
  :init
  (setq sml/name-width 60
        sml/no-confirm-load-theme t
        sml/shorten-directory t
        sml/show-file-name t
        sml/theme 'respectful
        sml/use-projectile-p 'before-prefixes
        rm-whitelist " FlyC*"
        rm-blacklist " Fly\\'")

  (sml/setup)

  (--each '(("^~/Code/" ":Code:")
            ("^~/Code/gh/" ":Github:")
            ("^~/Code/forks/" ":forks:"))
    (push it sml/replacer-regexp-list)))
#+END_SRC

** Zenburn Theme
[[https://github.com/bbatsov/solarized-emacs][Solarized]] is so good.

#+BEGIN_SRC emacs-lisp
(use-package zenburn-theme
  :init
  (setq zenburn-override-colors-alist
        '(("zenburn-green-2" . "#6d926d")))
  :config
  (set-face-attribute 'region nil
                      :background "#5c5c5c")
  (set-face-attribute 'font-lock-type-face nil
                      :weight 'bold))
#+END_SRC

** Rainbow Delimiters
[[https://github.com/Fanael/rainbow-delimiters][Rainbow Delimiters]] help with coloring parentheses and brackets and others. I mainly use
it to change all the delimiters colors to one.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :config
  (setq rainbow-delimiters-max-face-count 1)

  (--each '(prog-mode-hook
            emacs-lisp-mode-hook
            org-mode-hook
            markdown-mode-hook
            web-mode-hook)
    (add-hook it #'rainbow-delimiters-mode))

  (--each '(rainbow-delimiters-depth-1-face
            rainbow-delimiters-depth-2-face
            rainbow-delimiters-depth-3-face
            rainbow-delimiters-depth-4-face
            rainbow-delimiters-depth-5-face
            rainbow-delimiters-depth-6-face
            rainbow-delimiters-depth-7-face
            rainbow-delimiters-depth-8-face
            rainbow-delimiters-depth-9-face)
    (set-face-attribute it nil :foreground "#FC5353"))

  (set-face-attribute 'rainbow-delimiters-unmatched-face nil
                      :foreground "#dfaf8f"
                      :background "#FC5353"
                      :inverse-video nil))
#+END_SRC

** Prettify Symbols
Automatically transform symbols like lambda into the greek letter =λ=

#+BEGIN_SRC emacs-lisp
(--each '(org-mode-hook
          ruby-mode-hook)
  (add-hook it
            (lambda () (add-to-list 'prettify-symbols-alist '("lambda" . ?λ)))))

(--each '(js-mode-hook
          js2-mode-hook
          rjsx-mode-hook)
  (add-hook it
            (lambda () (setq-local prettify-symbols-alist nil))))

(--each '(python-mode-hook)
  (add-hook it
            (lambda () (setq-local prettify-symbols-alist '(("lambda" . ?λ))))))

(add-hook 'org-mode-hook
          (lambda ()
            ;; Prettify Org headers
            (setq-local prettify-symbols-compose-predicate (lambda (_start _end _match) t))
            (add-to-list 'prettify-symbols-alist '("*" . ?●))))

(global-prettify-symbols-mode)
#+END_SRC

** Highlight the Current Line
For easily identification of the current line.

#+BEGIN_SRC emacs-lisp
(global-hl-line-mode)
#+END_SRC

** Set the Default Font
I really like [[https://en.wikipedia.org/wiki/Menlo_(typeface)][Menlo]] font, it's shipped by default with OS X.

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'default nil :font "Menlo" :height 120)
#+END_SRC

Use an Arabic font for Arabic unicode characters

#+BEGIN_SRC emacs-lisp
(let ((my-font "Noto Sans Arabic UI"))
  (set-fontset-font "fontset-startup" '(#x000600 . #x0006FF) my-font)
  (set-fontset-font "fontset-default" '(#x000600 . #x0006FF) my-font)
  (set-fontset-font "fontset-standard" '(#x000600 . #x0006FF) my-font))
#+END_SRC

** Proportional Font
For regular writing I like to have a proportional font. [[https://github.com/khaledhosny/sahl-naskh][Sahl Naskh]] is
an improved fork of Droid Arabic Naskh.

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'variable-pitch nil
                    :font "Sahl Naskh"
                    :height 160
                    :width 'normal
                    :weight 'normal)

(bind-keys ("C-x t v" . variable-pitch-mode))
#+END_SRC

** Tramp
Tramp allows Emacs to edit files over SSH.

#+BEGIN_SRC emacs-lisp
(setq tramp-persistency-file-name (concat my/history-dir "tramp"))
#+END_SRC

** Eshell
#+BEGIN_SRC emacs-lisp
(use-package eshell
  :commands eshell
  :config
  (setq eshell-history-file-name (concat my/history-dir "eshell/history")
        eshell-scroll-to-bottom-on-input 'all
        eshell-error-if-no-glob t
        eshell-hist-ignoredups t
        eshell-save-history-on-exit t
        eshell-glob-case-insensitive t
        eshell-cmpl-ignore-case t))
#+END_SRC

** Ediff
A few configurations and styles for Emacs Ediff.

#+BEGIN_SRC emacs-lisp
(add-hook 'ediff-mode-hook
          (lambda ()
(setq ediff-merge-split-window-function 'split-window-vertically
      ediff-split-window-function  'split-window-horizontally
      ediff-window-setup-function 'ediff-setup-windows-plain)

(set-face-attribute 'ediff-current-diff-C nil :background "#41421c")
(set-face-attribute 'ediff-fine-diff-A nil :background "#630813")
(set-face-attribute 'ediff-fine-diff-B nil :background "#0a4c1b")))
#+END_SRC

** Dired
A few configuration for Emacs Dired mode.

#+BEGIN_SRC emacs-lisp
(defun my/dired-view-file ()
  "Exactly like `dired-view-file' expect it uses `view-file-other-window' instead of `view-file'"
  (interactive)
  (let ((file (dired-get-file-for-visit)))
    (if (file-directory-p file)
        (or (and (cdr dired-subdir-alist)
                 (dired-goto-subdir file))
            (dired file))
      (view-file-other-window file))))

(use-package dired
  :ensure nil
  :bind (:map dired-mode-map
              ("C-l" . dired-up-directory)
              ("w" . wdired-change-to-wdired-mode)
              ("v" . my/dired-view-file))
  :config
  (setq dired-listing-switches "-alh"
        dired-recursive-deletes 'always)
  ;; Group directories first on OS X if coreutils `ls' is installed
  (when (and (on-osx-p) (executable-find "gls"))
    (setq insert-directory-program "gls"
          dired-listing-switches (concat dired-listing-switches " --group-directories-first")))

  (use-package dired-x
    :ensure nil))
#+END_SRC

** Winner
Winner mode gives you the ability to undo and redo your window configuration, watch
this [[https://www.youtube.com/watch?v%3DT_voB16QxW0][video]] for better explanation.

#+BEGIN_SRC emacs-lisp
(use-package winner
  :init (winner-mode))
#+END_SRC

** Abbrevs
Useful for defining expandable abbreviations

#+BEGIN_SRC emacs-lisp
(setq save-abbrevs t
      abbrev-file-name (concat my/history-dir "abbrev_defs"))
(setq-default abbrev-mode t)
#+END_SRC

** Ispell & Flyspell
Emacs spell checker, and flyspell runs ispell on the fly. Use hunspell because it's more powerful and supports Arabic.

#+BEGIN_SRC emacs-lisp
(setq ispell-program-name "hunspell"
      ispell-dictionary "en_US"
      ispell-really-hunspell t
      ispell-keep-choices-win t
      ispell-use-framepop-p nil
      ispell-local-dictionary-alist '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8)))

(add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_SRC" . "#\\+END_SRC"))
#+END_SRC

Use both Ispell and abbrev together. ([[http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html][source]])

#+BEGIN_SRC emacs-lisp
(defun ispell-word-then-abbrev (p)
  "Call `ispell-word'. Then create an abbrev for the correction made.
With prefix P, create local abbrev. Otherwise it will be global."
  (interactive "P")
  (let ((before (downcase (or (thing-at-point 'word) "")))
        after)
    (call-interactively 'ispell-word)
    (setq after (downcase (or (thing-at-point 'word) "")))

    (unless (string= after before)
      (message "\"%s\" now expands to \"%s\" %sally" before after (if p "loc" "glob"))

      (define-abbrev (if p local-abbrev-table global-abbrev-table)
        before after))))

(bind-keys ("C-x t i" . ispell-word-then-abbrev))
#+END_SRC

Unbind those keys from flyspell-mode

#+BEGIN_SRC emacs-lisp
(add-hook 'flyspell-mode-hook
          (lambda ()
            (unbind-key "C-." flyspell-mode-map)
            (unbind-key "C-;" flyspell-mode-map)))
#+END_SRC

** Compilation Result
I don't like line truncation on compilation buffer, it's nicer to look at.

#+BEGIN_SRC emacs-lisp
(add-hook 'compilation-mode-hook (lambda () (setq-local truncate-lines nil)))
#+END_SRC

** Emacs Calculator
It's so much easier to hit =C-x 8 q= than =C-x * q= for the =quick-calc= command.

#+BEGIN_SRC emacs-lisp
(bind-keys ("C-x 8 q" . quick-calc))
#+END_SRC

** Emacs Client
I want =C-c C-c= to end the editing session.

#+BEGIN_SRC emacs-lisp
(add-hook 'server-visit-hook
          (lambda ()
            (local-set-key (kbd "C-c C-c") 'server-edit)))
#+END_SRC

** View Mode
The built in view-mode is useful when you just want to read a file. This ease the file navigation

#+BEGIN_SRC emacs-lisp
(use-package view
  :ensure nil
  :bind (("C-x C-q" . view-mode)
         :map view-mode-map
         ("n" . next-line)
         ("j" . next-line)
         ("p" . previous-line)
         ("k" . previous-line)
         ("/" . swiper))
  :config
  (add-hook 'view-mode-hook
            (lambda ()
              (make-variable-buffer-local 'line-move-visual)
              (setq-local line-move-visual nil)
              (setq-local hl-line-changed-cookie
                          (face-remap-add-relative 'hl-line '((:background "#734242")))))))
#+END_SRC

** Imenu Mode

#+BEGIN_SRC emacs-lisp
(defun my/vue-imenu-index ()
  (when (equal "vue" (file-name-extension (buffer-file-name)))
    (setq-local imenu-create-index-function
                (lambda () (imenu--generic-function
                       '(("Style" "^\\(<style.*>\\)" 1)
                         ("Function" "^\\s-*\\([[:alnum:]]+(.*)\\)\\s-*{" 1)
                         ("Localization" "^\\s-*\\(i18n:\\s-*{\\)" 1)
                         ("Methods" "^\\s-*\\(methods:\\s-*{\\)" 1)
                         ("Watch" "^\\s-*\\(watch:\\s-*{\\)" 1)
                         ("Computed" "^\\s-*\\(computed:\\s-*{\\)" 1)
                         ("Props" "^\\s-*\\(props:\\s-*{\\)" 1)
                         ("Components" "^\\s-*\\(components:\\s-*{\\)" 1)
                         ("Script" "^\\(<script.*>\\)" 1)
                         ("Template" "^\\(<template.*>\\)" 1)))))))

(defun my/imenu-default-goto-function (name position &rest args)
  (imenu-default-goto-function name position args)
  (recenter))

(add-hook 'web-mode-hook #'my/vue-imenu-index)
(setq-default imenu-default-goto-function 'my/imenu-default-goto-function)
#+END_SRC

** Pixel Scroll Mode

#+BEGIN_SRC emacs-lisp
(use-package pixel-scroll
  :ensure nil
  :init (pixel-scroll-mode))
#+END_SRC

** Hide Show Minor Mode

Hideshow is a builtin minor mode for code folding

#+BEGIN_SRC emacs-lisp
(defun my/hs-hide-rest ()
  "Hide everything in the buffer and only show the current block"
  (interactive)
  (hs-hide-all)
  (hs-show-block))

(bind-key "C-c @ @" 'my/hs-hide-rest)

(add-hook 'prog-mode-hook #'hs-minor-mode)
#+END_SRC

** Goto Address Mode

Minor mode that buttonizes URLs

#+BEGIN_SRC emacs-lisp
(use-package goto-addr
  :hook ((compilation-mode . goto-address-mode)
         (prog-mode . goto-address-mode))
  :bind (:map goto-address-highlight-keymap
              ("M-<return>" . goto-address-at-point)))
#+END_SRC


** Change Emacs Keybinding
*** Unbinding
Unbind these keys because they are used for something else.

#+BEGIN_SRC emacs-lisp
(unbind-key "C-;")
(unbind-key "C-x m")
#+END_SRC

*** Preferred Binding for Default Commands
These are my personal preference to the default Emacs keybindings.

#+BEGIN_SRC emacs-lisp
(bind-keys ("RET" . reindent-then-newline-and-indent)
           ("C-w" . backward-kill-word)
           ("C-x C-k" . kill-region)
           ("M-/" . hippie-expand)
           ("C-x t l" . toggle-truncate-lines)
           ("C-<tab>" . indent-for-tab-command)
           ("C-x s" . save-buffer)
           ("C-h a" . apropos)
           ("C-x C-<tab>" . indent-rigidly))
#+END_SRC

*** Window Movement
Use =Shift-<arrow key>= to move between windows.

#+BEGIN_SRC emacs-lisp
(windmove-default-keybindings)
#+END_SRC

Make =C-x o= switch to next window and =C-x C-o= switch to previous window.

#+BEGIN_SRC emacs-lisp
(defun my/switch-window-forward ()
  (interactive)
  (other-window 1))

(defun my/switch-window-backward ()
  (interactive)
  (other-window -1))

(bind-keys ("C-x o" . my/switch-window-backward)
           ("C-x C-o" . my/switch-window-forward))
#+END_SRC

*** Quick Switch to Previous Buffer
I use =M-`= to toggle between two buffers.

#+BEGIN_SRC emacs-lisp
(defun my/previous-buffer (args)
  (interactive "P")
  (if args
      (ff-find-other-file)
    (switch-to-buffer (other-buffer (current-buffer)))))

(bind-key "M-`" 'my/previous-buffer)
#+END_SRC

*** Window Splitting
Make windows splitting by default use horizontal split

#+BEGIN_SRC emacs-lisp
(setq split-height-threshold nil)
#+END_SRC

Copied from [[http://www.reddit.com/r/emacs/comments/25v0eo/you_emacs_tips_and_tricks/chldury][reddit comment]]. Makes the newly created window set to the previous buffer.

#+BEGIN_SRC emacs-lisp
(defun my/vertical-split-buffer (prefix)
  "Split the window vertically and display the previous buffer."
  (interactive "p")
  (split-window-vertically)
  (other-window 1 nil)
  (if (= prefix 1) (switch-to-next-buffer)))

(defun my/horizontal-split-buffer (prefix)
  "Split the window horizontally and display the previous buffer."
  (interactive "p")
  (split-window-horizontally)
  (other-window 1 nil)
  (if (= prefix 1) (switch-to-next-buffer)))

(bind-keys ("C-x 2" . my/vertical-split-buffer)
           ("C-x 3" . my/horizontal-split-buffer))
#+END_SRC


* OS Specific Configuration
These are configuration specific to OSs. Mostly OS X for now.

** Use Dark Frames

A feature of Emacs 26.1

#+BEGIN_SRC emacs-lisp
(when (and (on-osx-p)
           (version<= "26.1" emacs-version))
  (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
  (add-to-list 'default-frame-alist '(ns-appearance . dark)))
#+END_SRC

** Fix Emacs Environment Variables on OS X
Emacs on OS X can't access the environment variables set in the shell profile. This help
us workaround that.

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :if (on-osx-p)
  :config
  (setq exec-path-from-shell-arguments nil
        exec-path-from-shell-variables '("PATH" "MANPATH" "BROWSER" "DICPATH"))

  (exec-path-from-shell-initialize))
#+END_SRC

** Set Command as Meta

#+BEGIN_SRC emacs-lisp
(when (on-osx-p)
  (setq ns-alternate-modifier 'super
        ns-command-modifier 'meta
        ns-control-modifier 'control))
#+END_SRC

** Set the Default Browser

#+BEGIN_SRC emacs-lisp
(when (on-osx-p)
  (setq browse-url-browser-function 'browse-url-chromium
        browse-url-chromium-program "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome"))
#+END_SRC

** OS X Arabic Keybaord
Emacs default Arabic keyboard layout doesn't match with the default OS X layout, this
fixes that.

#+BEGIN_SRC emacs-lisp
(when (on-osx-p)
  (load "arabic-mac")
  (setq default-input-method "arabic-mac"))
#+END_SRC

** Emoji Support 🌈

See my [[https://github.com/a3ammar/homebrew-emacs-emoji][homebrew formula]]

#+BEGIN_SRC emacs-lisp
(when (on-osx-p)
  (set-fontset-font t 'symbol (font-spec :family "Apple Color Emoji") nil 'prepend))
#+END_SRC

** Trash Files Instead of Deleting Them
I [[https://github.com/ali-rantakari/trash][trash]] command to move files to the system trash instead of deleting them. Make Emacs use it.

#+BEGIN_SRC emacs-lisp
(defun my/system-move-file-to-trash (file)
  "Use the command `trash' to move `file' to the system trash"
  (call-process (executable-find "trash") nil 0 nil file))

(when (on-osx-p)
  (defalias 'move-file-to-trash 'my/system-move-file-to-trash))
#+END_SRC

** Switch Back to Terminal After Emacs Client Exit
Whenever I'm on a terminal I use =emacsclient= to edit a file, this will switch back to
the terminal after editing the file.

#+BEGIN_SRC emacs-lisp
(defun my/focus-terminal ()
  ;; Don't switch if we are committing to git
  (unless (or (get-buffer "COMMIT_EDITMSG")
              (get-buffer "git-rebase-todo"))
    (do-applescript "tell application \"Terminal\" to activate")))

(when (on-osx-p)
  (add-hook 'server-done-hook #'my/focus-terminal))
#+END_SRC


*p Appearance
** Emacs GUI Default Configuration
I rarely, if ever, use the mouse in Emacs. This disable the GUI elements.

#+BEGIN_SRC emacs-lisp
(when window-system
  (tooltip-mode -1)
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1))
#+END_SRC

Don't ever use GUI dialog boxes.

#+BEGIN_SRC emacs-lisp
(setq use-dialog-box nil)
#+END_SRC

Resize Emacs window (called frame in Emacs jargon) as pixels instead of chars resulting in fully sized window.

#+BEGIN_SRC emacs-lisp
(setq frame-resize-pixelwise t)
#+END_SRC

Remember cursor position when scrolling.

#+BEGIN_SRC emacs-lisp
(setq scroll-preserve-screen-position 'always)
#+END_SRC

Add a bigger offset to underline property (it makes smart-mode-line looks way nicer).

#+BEGIN_SRC emacs-lisp
(setq underline-minimum-offset 4)
#+END_SRC


* Global Modes
Configuration for modes that are always running no matter which buffer
we are in.

** Smartparens
[[https://github.com/Fuco1/smartparens][Smartparens]] manages pairs for you, so if you insert =(= it automatically inserts
the closing pair.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :pin melpa-stable
  :bind (:map sp-keymap
              ("M-<backspace>" . sp-unwrap-sexp)
              ("M-." . sp-slurp-hybrid-sexp)
              ("M-," . sp-forward-barf-sexp)
              ("C-M-." . sp-backward-slurp-sexp)
              ("C-M-," . sp-backward-barf-sexp))
  :init
  (smartparens-global-mode)
  :config
  (setq sp-base-key-bindings 'sp
        sp-highlight-pair-overlay nil
        sp-highlight-wrap-overlay nil
        sp-highlight-wrap-tag-overlay nil)

  (use-package smartparens-config :ensure nil)
  (sp-use-smartparens-bindings)

  (sp-pair "(" nil :post-handlers '(("| " "SPC")))
  (sp-pair "[" nil :post-handlers '(("| " "SPC")))
  (sp-pair "{" nil :post-handlers '(("| " "SPC")))

  (add-hook 'ruby-mode-hook
            (lambda ()
              (sp-local-pair 'ruby-mode "{" nil :post-handlers '(("| " "SPC")))))

  (add-hook 'nxml-mode-hook
            (lambda ()
              (sp-local-pair 'nxml-mode "<" ">" :actions :rem)))

  (add-hook 'web-mode-hook
            (lambda ()
              (sp-local-pair 'web-mode "<" nil :actions :rem)
              (sp-local-pair 'web-mode "<%" "%>" :post-handlers '(("| " "SPC") (" | " "=")))
              (sp-local-pair 'web-mode "{%" "%}" :post-handlers '(("| " "SPC")))))

  ;; Do not escape closing pair in string interpolation
  (add-hook 'swift-mode-hook
            (lambda ()
              (sp-local-pair 'swift-mode "\\(" nil :actions :rem)
              (sp-local-pair 'swift-mode "\\(" ")")))

  (set-face-attribute 'sp-show-pair-match-face nil
                      :foreground nil
                      :background "#735757")

  (show-smartparens-global-mode))
#+END_SRC

Change beginning/end of s-expression movement to go outside of the s-expression when the =point= is at the beginning/end of the s-expression.

#+BEGIN_SRC emacs-lisp
(defun my/sp-beginning-of-sexp ()
  "Move to the beginning of sexp, if at beginning then move before it"
  (interactive)
  (let* ((sexp (or (sp-get-enclosing-sexp) (sp-get-sexp)))
         (beginning (sp-get sexp :beg-in)))
    (if (= beginning (point))
        (goto-char (1- beginning))
      (sp-beginning-of-sexp))))

(defun my/sp-end-of-sexp ()
  "Move to the end of sexp, if at end then move after it"
  (interactive)
  (let* ((sexp (or (sp-get-enclosing-sexp) (sp-get-sexp)))
         (end (sp-get sexp :end-in)))
    (if (= end (point))
        (goto-char (1+ end))
      (sp-end-of-sexp))))

(bind-keys :map sp-keymap
           ("C-M-a" . my/sp-beginning-of-sexp)
           ("C-M-e" . my/sp-end-of-sexp))
#+END_SRC

** Company Mode
[[http://company-mode.github.io/][Company Mode]] is a text completion framework for Emacs.

#+BEGIN_SRC emacs-lisp
(use-package company
  :config
  (setq company-global-modes '(not inf-ruby-mode eshell-mode)
        company-idle-delay 0.3
        company-minimum-prefix-length 3
        company-dabbrev-downcase nil)

  (add-hook 'company-mode-hook
            (lambda ()
              (set-face-attribute 'company-template-field nil
                                  :foreground nil
                                  :background nil
                                  :inherit 'region)))

  (global-company-mode))
#+END_SRC

When Company suggestions is shown pressing =C-w= will be captured by Company and will not execute =backward-kill-word=.

#+BEGIN_SRC emacs-lisp
(defun my/company-abort ()
  "Make company mode not steal C-w and instead pass it down"
  (interactive)
  (company-abort)
  (execute-kbd-macro (kbd "C-w")))

(bind-keys :map company-active-map
          ("C-w" . my/company-abort))
#+END_SRC

** LSP Mode

[[https://github.com/emacs-lsp/][LSP Mode]] is emacs' integration for the Language Server Protocol

#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  :hook (prog-mode . lsp-deferred)
  :commands (lsp lsp-deferred)
  :config
  (setq lsp-session-file (concat my/history-dir "lsp-session")
        lsp-enable-symbol-highlighting nil
        lsp-restart 'ignore))
#+END_SRC


** Ace Window
[[https://github.com/abo-abo/ace-window][ace-window]] is a replacment for the =other-window= command

#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :bind (("C-x C-o" . ace-window)
         ("C-x o" . ace-window))
  :config
  (setq aw-keys '(?j ?k ?l ?u ?i ?o ?p ?n ?m))

  (set-face-attribute 'aw-leading-char-face nil :height 180))
#+END_SRC

** Popwin
[[https://github.com/m2ym/popwin-el][Popwin]] makes popup window awesome again, every popup window can be closed by =C-g=.

#+BEGIN_SRC emacs-lisp
(use-package popwin
  :bind ("C-h e" . popwin:messages)
  :bind-keymap ("C-z" . popwin:keymap)
  :init
  (autoload 'popwin-mode "popwin.el" nil t)
  (popwin-mode)
  :config
  (--each '(("*rspec-compilation*" :tail nil)
            "*Apropos*"
            "*Warnings*"
            "*projectile-rails-server*"
            "*coffee-compiled*"
            "*Bundler*"
            "*projectile-rails-compilation*"
            "*Ack-and-a-half*"
            ("*ruby*" :height 0.75)
            ("*rails*" :height 0.75)
            "*Compile-Log*"
            "*pry*"
            "*SQL*"
            "*projectile-rails-generate*"
            "*Package Commit List*"
            "*Compile-Log*"
            (" *undo-tree*" :position bottom)
            "*compilation*"
            ("RuboCop.*" :regexp 't)
            "*elm*"
            "*xcrun swift*"
            ("*HTTP Response*" :position bottom :height 30)
            "*Flycheck errors*"
            ("*Flycheck error messages*" :noselect t)
            "*js*"
            "*Python*"
            "*cider-error*"
            "*cider-doc*")
    (push it popwin:special-display-config)))
#+END_SRC

Focus help popup so we can exit it easily with popwin.

#+BEGIN_SRC emacs-lisp
(setq help-window-select t)
#+END_SRC

** Persistent Sractch
[[https://github.com/Fanael/persistent-scratch/][Persistent Scratch]] saves and restores the scratch buffer between Emacs restarts.

#+BEGIN_SRC emacs-lisp
(use-package persistent-scratch
  :config
  (setq persistent-scratch-save-file (concat my/history-dir "persistent-scratch"))

  (persistent-scratch-setup-default))
#+END_SRC

** Flycheck
[[http://www.flycheck.org/en/latest/][Flycheck]] is a modern lint runner.

#+BEGIN_SRC emacs-lisp
(defun my/current-buffer-is-a (extension)
  "Return true if current buffer name ends with `extension'"
  (let ((file (buffer-file-name (current-buffer))))
    (s-ends-with? extension file)))

(use-package flycheck
  :bind (("C-c ! ," . flycheck-list-errors))
  :config
  (setq flycheck-indication-mode 'right-fringe
        flycheck-navigation-minimum-level 'error
        flycheck-idle-change-delay 1
        flycheck-check-syntax-automatically '(save idle-change))

  (add-hook 'js2-mode-hook
            (lambda ()
              (direnv-update-environment default-directory)
              (when (executable-find "eslint_d")
                (setq flycheck-javascript-eslint-executable "eslint_d"))
              (setq-local flycheck-checker 'javascript-eslint)))

  (flycheck-add-mode 'javascript-eslint 'web-mode)
  (add-hook 'web-mode-hook
            (lambda ()
              (direnv-update-environment default-directory)
              (when (executable-find "eslint_d")
                (setq flycheck-javascript-eslint-executable "eslint_d"))
              (setq-local flycheck-checker 'javascript-eslint)))

  (add-hook 'emacs-lisp-mode-hook
            (lambda () (add-to-list 'flycheck-disabled-checkers 'emacs-lisp-checkdoc)))

  (set-face-attribute 'flycheck-error nil
                      :background "#885f5f"
                      :underline '(:style wave :color "#BC8383"))

  (global-flycheck-mode))
#+END_SRC

Show flycheck errors in a popup

#+BEGIN_SRC emacs-lisp
(use-package flycheck-popup-tip
  :config
  (add-hook 'flycheck-mode-hook #'flycheck-popup-tip-mode)
  (set-face-attribute 'popup-tip-face nil
                      :background nil
                      :foreground nil
                      :inherit 'company-tooltip))
#+END_SRC

** Aggressive Indent
[[https://github.com/Malabarba/aggressive-indent-mode][Agggressive Indent Mode]] automatically indents s-expression. It's magical.

#+BEGIN_SRC emacs-lisp
(defun in-web-mode-js? ()
  (string= (plist-get (web-mode-point-context (point)) :language) "javascript"))

(use-package aggressive-indent
  :commands aggressive-indent-mode
  :config
  (add-to-list 'aggressive-indent-dont-indent-if
               '(and (derived-mode-p 'sgml-mode)
                     (string-match "^[[:space:]]*{%"
                                   (thing-at-point 'line))))
  (add-to-list 'aggressive-indent-dont-indent-if '(in-web-mode-js?)))
#+END_SRC

** Yasnippet
[[https://github.com/joaotavora/yasnippet][Yasnippet]] is a snippet expansion framework for Emacs.

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :defer t
  :init
  (setq yas-snippet-dirs '("~/.emacs.d/snippets/"))
  (yas-global-mode))
#+END_SRC

Use the [[https://github.com/AndreaCrotti/yasnippet-snippets][Yasnippet official snippet collections]]

#+BEGIN_SRC emacs-lisp
(use-package yasnippet-snippets
  :defer t)
#+END_SRC

** Undo Tree
[[http://www.dr-qubit.org/Emacs_Undo_Tree_package.html][Undo Tree]] is a better undo/redo alternative.

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :bind ("C-M-_" . undo-tree-visualize)
  :init
  (global-undo-tree-mode))
#+END_SRC

** Smex
[[https://github.com/nonsequitur/smex][Smex]] sorts used commands by frequency. Ivy automatically uses it for sorting when it's present.

#+BEGIN_SRC emacs-lisp
(use-package smex
  :config
  (setq smex-history-length 10
        smex-save-file (concat my/history-dir "smex-items")))
#+END_SRC


* Project Management & Navigation
Modes and configuration specific to managing and navigating projects.

** Ivy - Interactive Completion
[[https://github.com/abo-abo/swiper][Ivy]] is a lightweight completion system

#+BEGIN_SRC emacs-lisp
(use-package ivy
  :bind (("C-s" . swiper)
         ("C-x c b" . ivy-resume)
         :map ivy-minibuffer-map
         ("<return>" . ivy-alt-done))
  :config
  (setq ivy-use-virtual-buffers t
        ivy-height 15
        ivy-extra-directories nil
        ivy-magic-tilde nil
        ivy-switch-buffer-faces-alist '((dired-mode . ivy-subdir)
                                        (org-mode . org-macro))
        ivy-ignore-buffers '("\\*HTTP Response\\*" "\\*magit.*"))

  ;; Don't wrap lines in ivy-occur
  (add-hook 'ivy-occur-grep-mode-hook #'toggle-truncate-lines)

  (set-face-attribute 'ivy-minibuffer-match-face-2 nil
                      :background nil
                      :inherit 'isearch)

  (set-face-attribute 'ivy-virtual nil
                      :foreground "#c2d2d3"
                      :weight 'bold
                      :inherit nil)

  (ivy-mode))
#+END_SRC

Counsel adds a lot of extra functionality & integraion to ivy-mode

#+BEGIN_SRC emacs-lisp
(use-package counsel
  :bind (("C-x C-m" . counsel-M-x)
         ("C-x m" . counsel-M-x)
         ("M-y" . counsel-yank-pop)
         ("C-x C-f" . counsel-find-file)
         ("C-x C-i" . counsel-semantic-or-imenu)
         ("C-x c p" . counsel-list-processes)
         ("M-?" . counsel-company)
         ("C-h f" . counsel-describe-function)
         ("C-h v" . counsel-describe-variable)
         ("C-h l" . counsel-find-library)
         ("C-h i" . counsel-info-lookup-symbol)
         ("C-h u" . counsel-unicode-char)
         :map counsel-find-file-map
         ("C-l" . ivy-backward-delete-char))
  :config
  (setq ivy-initial-inputs-alist nil
        counsel-preselect-current-file 't
        counsel-yank-pop-separator "\n\n"
        counsel-find-file-ignore-regexp "\\`\\(\\..*\\|__pycache__\\|.*\\.pyc\\|.*\\.o\\)\\'")

  (defalias 'cpkg 'counsel-package)

  ;; Add copy, move, and delete commands to counsel-find-file
  (defun given-file (command prompt)
    "Run `command' with `prompt', `source', and `target'. `source' is set from `ivy' and `target' is set from prompting the user"
    (apply-partially
     '(lambda (command prompt source)
        (let ((target (read-file-name (format "%s %s to:" prompt source))))
          (funcall command source target 1)))
     command prompt))

  (defun my/kill-buffer-and-trash-file (file)
    (when file
      (kill-buffer (get-file-buffer file)))
    (move-file-to-trash file))

  (ivy-add-actions
   'counsel-find-file
   `(("c" ,(given-file #'copy-file "Copy") "cp")
     ("d" my/kill-buffer-and-trash-file "rm")
     ("m" ,(given-file #'rename-file "Move") "mv"))))

#+END_SRC

[[https://github.com/Yevgnen/ivy-rich][ivy-rich]] provides extra information to ivy buffers

#+BEGIN_SRC emacs-lisp
(use-package ivy-rich
  :config
  (ivy-rich-mode)
  (setq ivy-rich-parse-remote-buffer nil
        ivy-rich-parse-remote-file-path nil))
#+END_SRC

** Projectile
[[https://github.com/bbatsov/projectile][Projectile]] mode is one the best packages Emacs have, more information is in this
[[http://tuhdo.github.io/helm-projectile.html][blog]] post.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :pin melpa-stable
  :bind-keymap (("C-c p" . projectile-command-map)
                ("C-c C-p" . projectile-command-map))
  :init
  (setq projectile-known-projects-file (concat my/history-dir "projectile-bookmarks.eld"))
  :config
  (projectile-global-mode)

  (setq projectile-enable-caching t
        projectile-cache-file (concat my/history-dir "projectile.cache")
        projectile-completion-system 'ivy
        projectile-file-exists-remote-cache-expire nil)

  (setq projectile-ignored-project-function
        (lambda (project)
          (--any? (s-starts-with? (expand-file-name it) project)
                  '("~/.zprezto/modules/"
                    "/usr/loca/"
                    "~/.rbenv/"))))

  (push "node_modules" projectile-globally-ignored-directories)
  (push ".direnv" projectile-globally-ignored-directories)

  (projectile-load-known-projects))
#+END_SRC

Add even more integration between Projectile and Ivy

#+BEGIN_SRC emacs-lisp
(use-package counsel-projectile
  :init
  (setq counsel-projectile-remove-current-buffer t
        counsel-projectile-remove-current-project t
        projectile-switch-project-action #'counsel-projectile-find-file)

  (counsel-projectile-mode))
#+END_SRC

Override =counsel-rg= and =counsel-projectile-rg= with my preference

#+BEGIN_SRC emacs-lisp
(defun my/counsel-rg ()
  "Search in the current directory"
  (interactive)
  (counsel-rg "" default-directory))

(defun get-ripgrep-type ()
  "Returns the approriate ripgrep type for an extension"
  (let ((extension (file-name-extension (buffer-file-name))))
    (cond ((string= extension "vue")
           "-t js")
          (t
           (concat "-t " extension)))))

(defun my/counsel-projectile-rg (arg)
  "Called with two prefix arguments it prompts for `rg' arguments.
Called with one prefix arugment it searches for files with the same extension as the current buffer
Otherwise it passes its argument to `counsel-projectile-rg'"
  (interactive "P")
  (cond ((equal arg '(16))
         (let ((current-prefix-arg '(4))) (counsel-projectile-rg)))
        ((equal arg '(4))
         ()
         (counsel-projectile-rg (get-ripgrep-type)))
        (t
         (counsel-projectile-rg arg))))

(bind-keys ("C-c s" . my/counsel-rg)
           ("C-c C-s" . my/counsel-rg)
           :map projectile-command-map
           ("s" . my/counsel-projectile-rg))
#+END_SRC


** Projectile Rails
[[https://github.com/asok/projectile-rails][Projectile Rails]] adds Rails integration to projectile.

#+BEGIN_SRC emacs-lisp
(use-package projectile-rails
  :config
  (setq projectile-rails-font-lock-face-name 'font-lock-builtin-face
        projectile-rails-stylesheet-re "\\.scss\\'")

  (set-face-attribute 'projectile-rails-keyword-face nil
                      :inherit 'font-lock-builtin-face)

  (--each '(ruby-mode-hook
            web-mode-hook
            yaml-mode-hook
            scss-mode-hook
            js2-mode-hook)
    (add-hook it (lambda () (when (projectile-project-p) (projectile-rails-on))))))
#+END_SRC

** Magit
[[https://magit.vc/][Magit]] is the best interface to Git

#+BEGIN_SRC emacs-lisp
(use-package magit
  :pin melpa-stable
  :commands (magit-status magit-file-popup)
  :bind (("C-c <return>" . magit-status)
         ("C-c M-g" . magit-file-popup))
  :config
  (setq magit-push-always-verify nil
        magit-use-sticky-arguments 'current
        magit-section-cache-visibility nil
        magit-revert-buffers 'silent
        magit-diff-refine-hunk 't
        magit-rebase-arguments '("--autostash")
        magit-completing-read-function 'ivy-completing-read
        magit-display-buffer-function #'magit-display-buffer-fullcolumn-most-v1
        magit-status-sections-hook '(magit-insert-status-headers
                                     magit-insert-merge-log
                                     magit-insert-rebase-sequence
                                     magit-insert-am-sequence
                                     magit-insert-sequencer-sequence
                                     magit-insert-bisect-output
                                     magit-insert-bisect-rest
                                     magit-insert-bisect-log
                                     magit-insert-untracked-files
                                     magit-insert-unstaged-changes
                                     magit-insert-staged-changes
                                     magit-insert-stashes
                                     magit-insert-unpulled-from-upstream
                                     magit-insert-unpulled-from-pushremote
                                     magit-insert-unpushed-to-pushremote
                                     magit-insert-unpushed-to-upstream
                                     magit-insert-recent-commits))

  ;; Set the initial visibility of magit sections
  (setq magit-section-initial-visibility-alist '((stashes . show)
                                                 (unpushed . show)
                                                 (recent . show)))

  (use-package magit-popup :pin melpa-stable)

  (use-package git-commit
    :config
    (add-to-list 'git-commit-setup-hook 'git-commit-turn-on-flyspell))

  (--each '(diff-added diff-refine-added)
    (set-face-attribute it nil
                        :foreground "#d9e9d9"
                        :background "#3F5F3F"))
  (--each '(diff-removed diff-refine-removed)
    (set-face-attribute it nil
                        :foreground "#e2d1d1"
                        :background "#7C4343"))

  (defun my/parse-repo-url (url)
    "convert a git remote location as a HTTP URL"
    (if (string-match "^http" url)
        url
      (replace-regexp-in-string "\\(.*\\)@\\(.*\\):\\(.*\\)\\(\\.git?\\)"
                                "https://\\2/\\3"
                                url)))
  (defun my/magit-open-repo ()
    "open remote repo URL"
    (interactive)
    (let ((url (magit-get "remote" "origin" "url")))
      (browse-url (my/parse-repo-url url))))


  ;; (magit-diff-visit-file FILE &optional OTHER-WINDOW FORCE-WORKTREE DISPLAY-FN)
  (defun my/magit-visit-file ()
    "visit file in other window without leaving magit status"
    (interactive)
    (let ((file (magit-file-at-point))
          (magit-buffer (car (seq-filter (apply-partially #'string-match-p "^magit:")
                                         (mapcar #'buffer-name (buffer-list))))))
      (magit-diff-visit-file-other-window file)
      (when magit-buffer
        (select-window (get-buffer-window magit-buffer)))))

  (bind-keys :map magit-status-mode-map
             ("I" . my/magit-open-repo)
             ("SPC" . my/magit-visit-file)))
#+END_SRC

** Browse at Remote
Browse current commit or file at its remote repo.

#+BEGIN_SRC emacs-lisp
(use-package browse-at-remote)
#+END_SRC


** Dirnev — Load Project Specific Environment Variables
Integrating Emacs with [[https://direnv.net/][direnv]] allows us to put project specific environment variables in =.envrc=

#+BEGIN_SRC emacs-lisp
(use-package direnv
  :defer 1
  :config (direnv-mode))
#+END_SRC

** Git Time Machine
[[https://github.com/pidu/git-timemachine][Git Time Machine]] allows you to step through your changes like a time machine.

#+BEGIN_SRC emacs-lisp
(use-package git-timemachine
  :commands git-timemachine)
#+END_SRC

** Clone Github Projects From Emacs
[[https://github.com/dgtized/github-clone.el][Github Clone]] allows you to clone or fork a repo on Github without
leaving Emacs.

#+BEGIN_SRC emacs-lisp
(use-package github-clone
  :commands github-clone)
#+END_SRC

** Insert GitHub gitignore templates
Using [[https://github.com/xuchunyang/gitignore-templates.el/tree/2b729c6b76ec940e15c1599a0105149c2e1f4b17][gitignore templates]]

#+BEGIN_SRC emacs-lisp
(use-package gitignore-templates)
#+END_SRC


* Invokable Modes
Configuration to modes that are run by a keybinding or from =M-x=.

** Multiple Cursors
[[https://github.com/magnars/multiple-cursors.el][Multiple Cursors]], as the name suggest, allows editing over multiple lines

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :bind (("C-c SPC" . mc/edit-lines)
         ("M-]" . mc/mark-next-like-this)
         ("M-[" . mc/mark-previous-like-this)
         ("M-}" . mc/unmark-next-like-this)
         ("M-{" . mc/unmark-previous-like-this))
  :config
  (unbind-key "<return>" mc/keymap)

  (setq mc/list-file (concat my/history-dir "mc-lists.el"))

  (set-face-attribute 'mc/cursor-bar-face nil
                      :foreground nil
                      :background "#022B35"
                      :inverse-video nil))
#+END_SRC

** Iedit
[[https://github.com/victorhge/iedit][Iedit]] lets you mark all occurrences of a word to edit them at the same time.

#+BEGIN_SRC emacs-lisp
(use-package iedit
  :commands iedit-mode
  :bind ("C-;" . iedit-mode))
#+END_SRC

** Move Text Mode
Makes you able to [[https://github.com/emacsfodder/move-text][move line]] or region up or down

#+BEGIN_SRC emacs-lisp
(use-package move-text
  :init
  (move-text-default-bindings))
#+END_SRC

** Easy Kill Mode
Makes marking and killing regions much [[https://github.com/leoliu/easy-kill][easier]]

#+BEGIN_SRC emacs-lisp
(use-package easy-kill
  :bind (("M-2" . easy-mark))
  :init
  (global-set-key [remap kill-ring-save] #'easy-kill))
#+END_SRC


** Avy
[[https://github.com/abo-abo/avy][Avy]] lets you jump to things.

#+BEGIN_SRC emacs-lisp
(use-package avy
  :commands avy-goto-char-timer
  :bind ("C-r" . avy-goto-word-1)
  :config
  ;; Displays the full of the match `af' instead of `a' then `f'.
  (setq avy-style 'de-bruijn
        avy-all-windows nil
        avy-all-window-alt 't)

  (avy-setup-default))
#+END_SRC

** Visual Regexp
[[https://github.com/benma/visual-regexp.el][Visual Regexp]] is a replacement for =query-regexp-replace=

#+BEGIN_SRC emacs-lisp
(use-package visual-regexp
  :commands qrr
  :config
  (defalias 'qrr 'vr/query-replace))
#+END_SRC

** Embrace
[[https://github.com/cute-jumper/embrace.el][Embrace mode]] makes surrounding words with pairs so easy

#+BEGIN_SRC emacs-lisp
(use-package embrace
  :bind ("C-'" . embrace-change))
#+END_SRC

** Paradox
[[https://github.com/Malabarba/paradox][Paradox]] is a better alternative to =package-list-packages=

#+BEGIN_SRC emacs-lisp
(use-package paradox
  :commands pkg
  :config
  (setq paradox-automatically-star t
        paradox-execute-asynchronously t
        paradox-lines-per-entry 1
        paradox-github-token t)

  (paradox-enable)

  (defalias 'pkg 'list-packages))
#+END_SRC

** REST Client
[[https://github.com/pashky/restclient.el][REST Client]] help explore HTTP REST webservices.

#+BEGIN_SRC emacs-lisp
(use-package restclient
  :mode ("\\.restclient" . restclient-mode)
  :commands restclient-mode)
#+END_SRC

** Which Key Mode
[[https://github.com/justbur/emacs-which-key][Which Key]] displays available keybindings in a popup

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :config
  (which-key-setup-side-window-bottom)
  (which-key-mode))
#+END_SRC

** Easy Increment & Decrement Numbers
[[https://github.com/cofi/evil-numbers][Evil Numbers]] makes incrementing and decrementing number easy.

#+BEGIN_SRC emacs-lisp
(use-package evil-numbers
  :commands (evil-numbers/inc-at-pt evil-numbers/dec-at-pt)
  :bind (("M-=" . evil-numbers/inc-at-pt)
         ("M--" . evil-numbers/dec-at-pt)))
#+END_SRC

** ESUP - Emacs Start Up Profiler
[[https://github.com/jschaf/esup][ESUP]] is an Emacs startup profiler.

#+BEGIN_SRC emacs-lisp
(use-package esup
  :commands esup)
#+END_SRC

** Shrink Whitespace
[[https://github.com/jcpetkovich/shrink-whitespace.el][It's a better]] replacement for the =just-one-space= command

#+BEGIN_SRC emacs-lisp
(use-package shrink-whitespace
  :commands shrink-whitespace
  :bind ("M-\\" . shrink-whitespace))
#+END_SRC

** Writable Grep

[[https://github.com/mhayashi1120/Emacs-wgrep/][wgrep]] makes [[http://manuel-uberti.github.io/emacs/2018/02/10/occur/][refactoring]] easier

#+BEGIN_SRC emacs-lisp
(use-package wgrep-ag)
#+END_SRC

** Dumb Jump

[[https://github.com/jacktasia/dumb-jump][dumb-jump]] is a simple jump-to command

#+BEGIN_SRC emacs-lisp
(defun my/dumb-jump (arg)
  (interactive "P")
  (if arg
      (dumb-jump-go-other-window)
    (dumb-jump-go)))

(use-package dumb-jump
  :bind (("M-g j" . my/dumb-jump)
         ("M-g b" . dumb-jump-back)
         ("M-g l" . dumb-jump-quick-look))
  :config
  (setq dumb-jump-selector 'ivy))
#+END_SRC

** Docker
[[https://github.com/Silex/docker.el][Docker Interface]] to emacs

#+BEGIN_SRC emacs-lisp
(use-package docker
  :pin melpa-stable
  :bind (("C-c d" . docker)))
#+END_SRC


* Associative Modes
Configuration to modes that are associated with file extensions.

** Text Mode

#+BEGIN_SRC emacs-lisp
(use-package text-mode
  :preface (provide 'text-mode)
  :ensure nil
  :mode ("\\.txt\\'" "\\.text\\'")
  :config
  (add-hook 'text-mode-hook
            (lambda ()
              (turn-on-flyspell)
              (setq-local word-wrap t))))
#+END_SRC

** Org Mode
General org-mode configuration

#+BEGIN_SRC emacs-lisp
(use-package org
  :mode ("\\.org\\'" . org-mode)
  :bind (:map org-mode-map
              ("M-p" . org-move-subtree-up)
              ("M-n" . org-move-subtree-down)
              ("C-c C-p" . nil))
  :config
  (setq org-log-done t
        org-adapt-indentation nil
        org-fontify-whole-heading-line t
        org-pretty-entities t
        org-use-sub-superscripts nil
        org-goto-interface 'outline
        org-goto-max-level 10
        org-imenu-depth 5
        org-src-fontify-natively t
        org-src-tab-acts-natively nil
        org-src-window-setup 'current-window
        org-edit-src-content-indentation 0
        org-startup-folded nil)

  (add-to-list 'org-structure-template-alist
               '("se" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))

  (add-hook 'org-mode-hook
            (lambda ()
              (toggle-truncate-lines)))

  ;; Allow org to run shell commands in source blocks
  (org-babel-do-load-languages 'org-babel-load-languages
                               '((shell . t)
                                 (emacs-lisp . t)))

  (set-face-attribute 'org-block nil :background "#3f3f3f")
  (--each '(org-document-title
            org-level-1
            org-level-2
            org-level-3
            org-level-4
            org-level-5
            org-level-6
            org-level-7
            org-level-8)
    (set-face-attribute it nil :font "Raleway" :height 180 :weight 'bold)))
#+END_SRC

When I'm editing org documents, sometimes I like to narrow to an org-mode section and use Next Section and Previous Section to move between the sections. (taken from this [[https://www.reddit.com/r/emacs/comments/60nb8b/favorite_builtin_emacs_commands/df8b7vm/][reddit comment]])

#+BEGIN_SRC emacs-lisp
(defun my/org-next ()
  (interactive)
  (when (buffer-narrowed-p)
    (beginning-of-buffer)
    (widen)
    (org-forward-heading-same-level 1))
  (org-narrow-to-subtree))

(defun my/org-previous ()
  (interactive)
  (when (buffer-narrowed-p)
    (beginning-of-buffer)
    (widen)
    (org-backward-heading-same-level 1))
  (org-narrow-to-subtree))

(bind-keys :map org-mode-map
           ("C-x t n" . my/org-next)
           ("C-x t p" . my/org-previous))
#+END_SRC

Exit org source edit and save the buffer

#+BEGIN_SRC emacs-lisp
(defun my/org-edit-src-exit-and-save ()
  (interactive)
  (org-edit-src-exit)
  (save-buffer))

(bind-keys :map org-src-mode-map
           ("C-x C-s" . my/org-edit-src-exit-and-save))
#+END_SRC

** Emacs Lisp Mode

#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook
          (lambda ()
            (aggressive-indent-mode)
            (turn-on-eldoc-mode)))
#+END_SRC

Sometimes I use elisp as a calculator, this evaluates the current s-expression and
if =universal-argument= is supplied it replaces it s-expression with its result.

#+BEGIN_SRC emacs-lisp
(defun eval-and-replace ()
  "Replace the preceding sexp with its value."
  (interactive)
  (backward-kill-sexp)
  (condition-case nil
      (prin1 (eval (read (current-kill 0)))
             (current-buffer))
    (error (message "Invalid expression")
           (insert (current-kill 0)))))

(defun eval-dwim (args)
  "If invoked with C-u then evaluate and replace the current expression, otherwise use regular `eval-last-sexp'"
  (interactive "P")
  (if args
      (eval-and-replace)
    (eval-last-sexp nil)))

(bind-keys :map emacs-lisp-mode-map
           ("C-x C-e" . eval-dwim))
#+END_SRC

** Ruby Mode

#+BEGIN_SRC emacs-lisp
(use-package ruby-mode
  :mode "\\.rb\\'"
  :interpreter "ruby"
  :bind (:map ruby-mode-map
              ("<return>" . reindent-then-newline-and-indent))
  :config
  (setq ruby-indent-level 2
        ruby-insert-encoding-magic-comment nil)

  ;; Highlight `&&' and `||' as a builtin ruby keywords
  (font-lock-add-keywords 'ruby-mode
                          '(("\\(&&\\|||\\)" . font-lock-builtin-face)))

  (use-package inf-ruby
    :commands (ruby-send-block-and-go ruby-send-region-and-go)
    :config
    (setq inf-ruby-default-implementation "pry")
    (add-hook 'ruby-mode-hook #'inf-ruby-minor-mode))

  (use-package rake
    :commands rake
    :config
    (setq rake-cache-file (concat my/history-dir "rake.cache")
          rake-completion-system 'ivy-read))

  (use-package rspec-mode
    :bind-keymap ("C-c C-," . rspec-mode-keymap)
    :config
    (setq rspec-compilation-skip-threshold 2
          rspec-snippets-fg-syntax 'concise
          rspec-use-spring-when-possible t
          rspec-use-bundler-when-possible t
          compilation-scroll-output t)

    (rspec-install-snippets)

    (add-hook 'rspec-compilation-mode-hook (lambda () (setq-local truncate-lines nil))))

  (use-package bundler
    :commands bundle-install)

  (use-package rubocop
    :commands (rubocop-check-project rubocop-check-current-file)
    :bind (("C-c r <" . my/rubocop-check-project)
           ("C-c r , " . my/rubocop-check-current-file))))
#+END_SRC


Override =rubocop= functions so they automatically switch to the compilation buffer

#+BEGIN_SRC emacs-lisp
(defun my/rubocop-check-current-file ()
  (interactive)
  (rubocop-check-current-file)
  (popwin:select-popup-window))

(defun my/rubocop-check-project ()
  (interactive)
  (rubocop-check-project)
  (popwin:select-popup-window))
#+END_SRC

[[https://github.com/JoshCheek/rcodetools][rcodetools]] provide a way to evaulate ruby code inside your buffer. The
way it works is you add ~# =>~ after an expression and then run ~xmp~
command and it will insert the result after the comment.

For [[http://emacsblog.org/2007/07/21/package-faves-rcodetools/][more information]].

#+BEGIN_SRC emacs-lisp
(use-package rcodetools
  :ensure nil
  :commands xmp
  :bind (:map ruby-mode-map ("C-c C-c" . xmp)))

;; (defadvice my/comment-dwim (around rct-hack activate)
;;   "If comment-dwim is successively called, add => mark."
;;   (if (and (eq major-mode 'ruby-mode)
;;            (eq last-command 'my/comment-dwim))
;;       (progn (insert "=>")
;;              (xmp))
;;     ad-do-it))
#+END_SRC

** Javascript Mode

#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :mode ("\\.js$")
  :config
  (setq js2-mode-show-parse-errors nil
        js2-mode-show-strict-warnings nil
        js2-mode-assume-strict t
        js2-basic-offset 2
        js2-bounce-indent-p t
        js-switch-indent-offset 2)

  ;; Highlight `require()' as a buildtin javascript keyword
  (font-lock-add-keywords 'js2-mode
                          '(("\\(require\\)(.*)" . (1 font-lock-keyword-face))))

  (set-face-attribute 'js2-function-param nil
                      :foreground nil
                      :inherit 'font-lock-constant-face)

  (use-package js-comint))
#+END_SRC

Set the built-in js-mode's indentation

#+BEGIN_SRC emacs-lisp
(setq js-indent-level 2)
#+END_SRC

Add [[https://github.com/felipeochoa/rjsx-mode][rjsx-mode]] to handle jsx files

#+BEGIN_SRC emacs-lisp
(use-package rjsx-mode
  :mode "\\.jsx\\'"
  :config
  (flycheck-add-mode 'javascript-eslint 'rjsx-mode))
#+END_SRC

** JSON mode

#+BEGIN_SRC emacs-lisp
(use-package json-mode
  :mode "\\.json$"
  :config
  (setq json-reformat:indent-width 2)
  (unbind-key "C-c C-p" json-mode-map)
  (add-hook 'json-mode-hook
            (lambda ()
              (show-smartparens-mode -1))))
#+END_SRC

** Python Mode

#+BEGIN_SRC emacs-lisp
(use-package python
  :bind (("RET" . newline-and-indent)
         ("M-n" . python-nav-forward-block)
         ("M-p" . python-nav-backward-block))
  :config
  (unbind-key "C-c C-p" python-mode-map)

  ;; Run pylint after flake8
  (flycheck-add-next-checker 'python-flake8 'python-pylint)

  ;; Remove `:' from `electric-indent-chars'
  (add-hook 'python-mode-hook
            (lambda ()
              (setq electric-indent-chars (remq ?: electric-indent-chars)))))
#+END_SRC

** Web Mode

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :pin melpa-stable
  :mode ("\\.html$" "\\.xml$" "\\.erb$" "\\.vue$" "\\.svg$" "\\.ts$")
  :config
  (setq web-mode-enable-block-face 't
        web-mode-enable-current-element-highlight 't
        web-mode-css-indent-offset 2
        web-mode-markup-indent-offset 2
        web-mode-code-indent-offset 2
        web-mode-auto-close-style 2
        web-mode-enable-auto-pairing nil
        web-mode-enable-auto-indentation nil
        web-mode-script-padding 0
        web-mode-style-padding 0)

  ;; Don't let web-mode align JS methods call
  (setq web-mode-indentation-params (remove '("lineup-calls" . t) web-mode-indentation-params))

  (setq-default web-mode-comment-formats
                '(("java" . "/*")
                  ("javascript" . "//")
                  ("php" . "/*")))

  (set-face-attribute 'web-mode-block-face nil
                      :foreground nil
                      :background nil
                      :inherit 'hl-line)

  (set-face-attribute 'web-mode-current-element-highlight-face nil
                      :foreground nil
                      :background "#383838"
                      :inherit 'sp-show-pair-match-face))
#+END_SRC

** CSS Mode

#+BEGIN_SRC emacs-lisp
(use-package css-mode
  :ensure nil
  :mode "\\'.css\\'"
  :config
  (setq css-indent-offset 2)

  (add-hook 'css-mode-hook
            (lambda () (subword-mode -1))))
#+END_SRC

** Scala Mode

#+BEGIN_SRC emacs-lisp
(use-package scala-mode
  :mode "\\.scala$")
#+END_SRC

** YAML Mode

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :mode "\\.yaml\\'"
  :bind (:map yaml-mode-map
              ("<return>" . newline-and-indent))
  :config
  (add-hook 'yaml-mode-hook #'turn-off-flyspell))
#+END_SRC

** Lua Mode

#+BEGIN_SRC emacs-lisp
(use-package lua-mode
  :mode "\\.lua\\'"
  :config
  (setq lua-indent-level 2))
#+END_SRC

** Markdown Mode

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :mode ("\\.md\\'" "\\.markdown\\'")
  :config
  (setq markdown-fontify-code-blocks-natively t
        markdown-list-indent-width 2
        markdown-command "kramdown")

  (unbind-key "C-c C-p" markdown-mode-map)

  (set-face-attribute 'markdown-bold-face nil
                      :weight 'bold
                      :inherit 'font-lock-builtin-face)
  (set-face-attribute 'markdown-header-face nil
                      :font "Raleway"
                      :height 180
                      :weight 'bold)
  (set-face-attribute 'markdown-pre-face nil
                      :inherit 'default))
#+END_SRC

** Shell Conf Mode

#+BEGIN_SRC emacs-lisp
(use-package sh-mode
  :ensure nil
  :mode ("\\.zsh\\'" "\\.gitignore\\'" "\\.envrc\\'" "\\.flowconfig\\'")
  :interpreter "zsh"
  :init
  (setq-default sh-basic-offset 2))
#+END_SRC

I use [[https://github.com/sorin-ionescu/prezto][prezto]] and I want to associate zsh files without extension to =sh-mode=

#+BEGIN_SRC emacs-lisp
(add-to-list 'magic-fallback-mode-alist
             '((lambda () (and (buffer-file-name)
                          (s-match ".*prezto.*" (buffer-file-name))))
               . sh-mode))
#+END_SRC

** Conf Mode

Associate systemd files with conf-mode

#+BEGIN_SRC emacs-lisp
(use-package conf-mode
  :mode ("\\(?:\\.service\\|\\.target\\|\\.path\\|\\.timer\\)\\'" . conf-unix-mode)
  :config
  ;; Unbind C-c C-p because it conflicts with projectile
  (unbind-key "C-c C-p" conf-mode-map))
#+END_SRC

** HAML Mode

#+BEGIN_SRC emacs-lisp
(use-package haml-mode
  :mode ("\\.haml\\'" "\\.haml\\.erb\\'")
  :bind (:map haml-mode-map
              ("<return>" . newline-and-indent))
  :config
  (add-hook 'haml-mode-hook #'rspec-mode))
#+END_SRC

** Coffeescript Mode

#+BEGIN_SRC emacs-lisp
(use-package coffee-mode
  :mode ("\\.coffee\\'" "\\.coffee\\.erb$")
  :config
  (setq coffee-compile-jump-to-error nil
        coffee-tab-width 2)

  (add-hook 'coffee-mode-hook #'rspec-mode))
#+END_SRC

** SQL Mode

#+BEGIN_SRC emacs-lisp
(use-package sql
  :mode "\\.sql"
  :config
  (add-hook 'sql-interactive-mode-hook #'toggle-truncate-lines))
#+END_SRC

** Jinja Mode
I edit jinja files with names like =example.conf.j2= so I want Emacs to strip the =.j2= extension and choose the proper major mode

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.j2\\'" ignore t))
#+END_SRC

** Elm mode

#+BEGIN_SRC emacs-lisp
(use-package elm-mode
  :mode "\\.elm\\'"
  :bind (:map elm-mode-map
              ("<return>" . newline-and-indent)))
#+END_SRC

** Haskell Mode

#+BEGIN_SRC emacs-lisp
(use-package haskell-mode
  :mode "\\.hs\\'")
#+END_SRC

** Swift Mode

#+BEGIN_SRC emacs-lisp
(use-package swift-mode
  :mode "\\.swift\\'"
  :config
  (setq swift-mode:basic-offset 2))
#+END_SRC

** Feature Mode

#+BEGIN_SRC emacs-lisp
(use-package feature-mode
  :mode "\\.feature\\'")
#+END_SRC

** PHP Mode

#+BEGIN_SRC emacs-lisp
(use-package php-mode
  :mode "\\.php\\'")
#+END_SRC

** GraphQL Mode

#+BEGIN_SRC emacs-lisp
(use-package graphql-mode
  :mode "\\.\\(graphql\\|gql\\)$")
#+END_SRC

** Dockerfile Mode

#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode
  :mode "Dockerfile")
#+END_SRC

** Go Mode

#+BEGIN_SRC emacs-lisp
(use-package go-mode
  :config
  (add-hook 'before-save-hook
            (lambda ()
              (when (string= major-mode "go-mode")
                (gofmt-before-save)))))
#+END_SRC

Override the =go-goto-*= methods to push to the mark ring before jumping

#+BEGIN_SRC emacs-lisp
(defun my/go-goto-arguments ()
  (interactive)
  (push-mark)
  (go-goto-arguments))

(defun my/go-goto-docstring ()
  (interactive)
  (push-mark)
  (go-goto-docstring))

(defun my/go-goto-imports ()
  (interactive)
  (push-mark)
  (go-goto-imports))

(defun my/go-goto-function ()
  (interactive)
  (push-mark)
  (go-goto-function))

(defun my/go-goto-function-name ()
  (interactive)
  (push-mark)
  (go-goto-function-name))

(defun my/go-goto-return-value ()
  (interactive)
  (push-mark)
  (go-goto-return-values))

(defun my/go-goto-method-receiver ()
  (interactive)
  (push-mark)
  (go-goto-method-receiver))

(bind-keys :map go-goto-map
           ("a" . my/go-goto-arguments)
           ("d" . my/go-goto-docstring)
           ("f" . my/go-goto-function)
           ("i" . my/go-goto-imports)
           ("m" . my/go-goto-method-receiver)
           ("n" . my/go-goto-function-name)
           ("r" . my/go-goto-return-value))
#+END_SRC

** TOML Mode

#+BEGIN_SRC emacs-lisp
(use-package toml-mode)
#+END_SRC


** Clojure Mode

#+BEGIN_SRC emacs-lisp
(use-package clojure-mode
  :config
  (add-hook 'clojure-mode-hook #'turn-on-eldoc-mode)
  (add-hook 'clojure-mode-hook #'aggressive-indent-mode)

  (use-package cider
    :pin melpa-stable
    :bind (:map cider-mode-map
                ("C-." . cider-find-var)
                ("C-," . cider-pop-back))
    :config
    (unbind-key "M-." cider-mode-map)
    (unbind-key "M-," cider-mode-map)))
#+END_SRC


** EIN mode

[[https://tkf.github.io/emacs-ipython-notebook/][Emacs IPython Notebook]] mode makes working with jupyter easier

#+BEGIN_SRC emacs-lisp
(use-package ein
  :config
  (add-hook 'ein:notebook-mode-hook
            (lambda ()
              (unbind-key "M-," ein:notebook-mode-map)
              (unbind-key "M-." ein:notebook-mode-map))))
#+END_SRC


** Yang Mode

#+BEGIN_SRC emacs-lisp
(use-package yang-mode)
#+END_SRC


** CC Mode

#+BEGIN_SRC emacs-lisp
(use-package cc-mode
  :mode ("\\.p4\\'" . c++-mode)         ; Use cc-mode for P4 files
  :config
  (unbind-key "C-c C-p" c-mode-map)
  (setq c-basic-offset 4)

  (add-hook 'c-mode-common-hook
            (lambda ()
              (c-set-offset 'brace-list-intro '+)
              (c-set-offset 'arglist-intro '++)
              (c-set-offset 'arglist-cont-nonempty '++)
              (c-set-offset 'inextern-lang 0)
              (setq sp-escape-quotes-after-insert nil)
              (semantic-mode)))

  (add-hook 'c++-mode-hook
            (lambda ()
              (setq flycheck-clang-language-standard "c++11"
                    flycheck-clang-pedantic 't)
              (when (my/current-buffer-is-a "p4")
                (electric-indent-mode nil))))

  ;; Workaround semantic and company issue
  (--each '(semantic-analyze-completion-at-point-function
            semantic-analyze-notc-completion-at-point-function
            semantic-analyze-nolongprefix-completion-at-point-function)
    (remove-hook 'completion-at-point-functions it))

  (use-package uncrustify-mode
    :bind ("C-c C-f" . uncrustify-buffer)))
#+END_SRC


** Protobuf Mode

#+BEGIN_SRC emacs-lisp
(use-package protobuf-mode
  :config
  (c-add-style "my/protobuf-style"
               '((c-basic-offset . 2)))
  (add-hook 'protobuf-mode-hook
            (lambda () (c-set-style "my/protobuf-style"))))
#+END_SRC

* Extra Functionality
Miscellaneous and extra functionality. The dump of my little functions.

** Newline Do What I Mean
This I took from somewhere, it insert a space if I do =M-return= between bracket or
parentheses, etc.

#+BEGIN_SRC emacs-lisp
(defun my/newline-dwim ()
  (interactive)
  (let ((break-open-pair (or (and (looking-back "{ ?") (looking-at " ?}"))
                             (and (looking-back ">") (looking-at "<"))
                             (and (looking-back "(") (looking-at ")"))
                             (and (looking-back "\\[") (looking-at "\\]")))))
    (newline)
    (when break-open-pair
      (save-excursion
        (newline)
        (indent-for-tab-command)))
    (indent-for-tab-command)))

(bind-keys ("M-<return>" . my/newline-dwim))
#+END_SRC

** Comment Do What I Mean
Better comments, taken from [[http://www.opensubscriber.com/message/emacs-devel@gnu.org/10971693.html][here]].

#+BEGIN_SRC emacs-lisp
(defun my/comment-dwim (&optional arg)
  "Replacement for the comment-dwim command.
 If no region is selected and current line is not blank and we are not at the end of the line, then comment current line.
 Replaces default behaviour of comment-dwim, when it inserts comment at the end of the line."
  (interactive "*P")
  (comment-normalize-vars)
  (if (and (not (region-active-p))
           (not (looking-at "[ \t]*$")))
      (comment-or-uncomment-region (line-beginning-position) (line-end-position))
    (comment-dwim arg)))

(bind-keys ("M-;" . my/comment-dwim))
#+END_SRC

** Duplicate Line

#+BEGIN_SRC emacs-lisp
(defun my/duplicate-line (&optional args)
  "duplicate the current line and while saving the current position"
  (interactive "P")
  (let ((column (current-column))
        (times (prefix-numeric-value args)))
    (-dotimes times
      (lambda (_)
        (move-beginning-of-line 1)
        (kill-line)
        (yank)
        (open-line 1)
        (next-line 1)
        (yank)
        (move-beginning-of-line 1)
        (move-to-column column)))))

(bind-keys ("C-x C-y" . my/duplicate-line))
#+END_SRC

** Flip Colon

#+BEGIN_SRC emacs-lisp
(defun my/flip-colons ()
  "Move colon `:' to beginning of the world if it's at the end or vice versa"
  (interactive)
  (let ((word (thing-at-point 'sexp))
        (bounds (bounds-of-thing-at-point 'sexp)))
    (when (or (s-starts-with-p ":" word)
              (s-ends-with-p ":" word))
      (delete-region (car bounds) (cdr bounds))
      (if (s-starts-with-p ":" word)
          (insert (s-append ":" (s-chop-prefix ":" word)))
        (insert (s-prepend ":" (s-chop-suffix ":" word)))))))

(bind-keys ("C-:" . my/flip-colons))
#+END_SRC

** Expand Inline Braces  to Multiline
Toggle inline rule into multiline, for example:

#+BEGIN_SRC css
// from this
h1 { font-size: 30px }

// into this
h1 {
  font-size: 30px;
}
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my/delete-or-insert-newline ()
  (if (looking-at "\n")
      (progn
        (delete-char 1)
        (just-one-space))
    (insert "\n")))

(defun my/toggle-brace ()
  (interactive)
  (let (start)
    (save-excursion
      (while (not (looking-back "{")) (backward-char))
      (setq start (point))
      (my/delete-or-insert-newline)
      (while (not (looking-at "\n? *}")) (forward-char))
      (my/delete-or-insert-newline)
      (indent-region start (line-end-position)))))

(bind-key "C-x t [" 'my/toggle-brace)
#+END_SRC

** Yank and Remove From History
This is useful when you want to paste sensitive information and do not want it to stay in the =kill-ring= variable. Like pasting a password to =tramp=.

#+BEGIN_SRC emacs-lisp
(defun yank-and-remove-from-killring ()
  (interactive)
  (yank)
  (setq kill-ring
        (remove (first kill-ring) kill-ring)))

(bind-keys ("C-M-y" . yank-and-remove-from-killring))
#+END_SRC

** Insert Arabic Tatweel Character
بعض الأحيان أحتاج أمـــــــــــد بعض الكلمات

#+BEGIN_SRC emacs-lisp
(defun my/insert-tatweel (arg)
  (interactive "P")
  (insert-char #x0640 arg))

(bind-keys ("C-x t _" . my/insert-tatweel))
#+END_SRC

** Indent the Buffer
Taken from [[https://github.com/magnars/.emacs.d/blob/master/defuns/buffer-defuns.el#L144-166][Magnars' Emacs]]

#+BEGIN_SRC emacs-lisp
(defun indent-buffer ()
  (interactive)
  (indent-region (point-min) (point-max)))
#+END_SRC

** Clean the Buffer
Taken from [[https://github.com/magnars/.emacs.d/blob/master/defuns/buffer-defuns.el#L144-166][Magnars' Emacs]]

#+BEGIN_SRC emacs-lisp
(defun cleanup-buffer ()
  "Perform a bunch of operations on the whitespace content of a buffer.
Including indent-buffer, which should not be called automatically on save."
  (interactive)
  (untabify-buffer)
  (delete-trailing-whitespace)
  (indent-buffer))
#+END_SRC

** Calculate Expression and Insert It
Useful for quick calculations, based on this reddit [[https://www.reddit.com/r/emacs/comments/445w6s/whats_some_small_thing_in_your_dotemacs_that_you/cznxx9f][post]].

#+BEGIN_SRC emacs-lisp
(defun my/calc-insert (arg)
  "Look for two numbers with a symbol between them and calculate their expression and replace them with the result"
  (interactive "p")
  (let (start end)
    (if (use-region-p)
        (setq start (region-beginning)
              end (region-end))
      (save-excursion
        (setq end (point))
        (setq start (search-backward-regexp "[0-9]+ ?[-+*/^] ?[0-9]+"
                                            (line-beginning-position) 1))))
    (let ((value (calc-eval (buffer-substring-no-properties start end))))
      (if (= arg 4)
          (message value)
        (delete-region start end)
        (insert value)))))

(bind-key "C-=" 'my/calc-insert)
#+END_SRC

** Open Line and Indent
I use =open-line= a lot and most of the time I have to manually indent the new line, lets fix this:

#+BEGIN_SRC emacs-lisp
(defun my/open-line (prefix)
  "Indent the new line after `open-line'"
  (interactive "P")
  (save-excursion
    (if prefix
        (newline)
      (newline-and-indent)))
  (indent-according-to-mode))

(bind-key "C-o" 'my/open-line)
#+END_SRC

** Switch Buffer — Do What I Mean
If we are inside a project and have multiple buffers open then use =projectile-switch-buffer= otherwise fallback to the normal =switch-buffer=

The =my/counsel-projectile-switch-to-buffer= is exactly the same as the original one except that it pre-selects the second buffer instead of the first.

#+BEGIN_SRC emacs-lisp
(defun my/switch-buffer-dwim (&optional prefix)
  (interactive "P")
  (if (and (null prefix)
           (projectile-project-p)
           (> (length (projectile-project-buffers)) 1))
      (call-interactively 'counsel-projectile-switch-to-buffer)
    (call-interactively 'ivy-switch-buffer)))

(bind-keys ("C-x b" . my/switch-buffer-dwim)
           ("C-x C-b" . my/switch-buffer-dwim))
#+END_SRC

** Rename File — Do What I Mean

Taken from [[http://emacsredux.com/blog/2013/05/04/rename-file-and-buffer/][this blog post]] makes renaming files less painful.

#+BEGIN_SRC emacs-lisp
(defun my/rename-file-dwim ()
  "Rename the current buffer and file it is visiting."
  (interactive)
  (let ((filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (message "Buffer is not visiting a file!")
      (let ((new-name (read-file-name "New name: " filename)))
        (rename-file filename new-name t)
        (set-visited-file-name new-name t t)))))
#+END_SRC

* Load Private Information
This file contains private information, like API keys, that I want to keep out of this repo.

#+BEGIN_SRC emacs-lisp
(load "~/.emacs.secrets" t)
#+END_SRC

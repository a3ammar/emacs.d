#+TITLE: My Emacs Configuration As an Org File

This is is inspired by [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha's]] Emacs configuration

* Configuration
** Personal Information

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Ammar Alammar"
      user-mail-address "ammar@ammasa.net")
#+END_SRC

** Emacs Initialization
*** Better Emacs Defaults

Emacs default configuration are awful, lets fix it.

If you want the meaning of these variables move the point to the desired variable
and press =C-h v=.

#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold (* 50 1024 1024)
      inhibit-startup-message t
      inhibit-startup-echo-area-message t
      echo-keystrokes 0.1
      ring-bell-function 'ignore
      scroll-conservatively 10
      hscroll-step 1
      mouse-wheel-scroll-amount '(0.01)
      mouse-wheel-progressive-speed nil
      font-lock-maximum-decoration t
      transient-mark-mode t
      delete-by-moving-to-trash t
      shift-select-mode nil
      comment-style 'multi-line
      uniquify-buffer-name-style 'forward
      truncate-partial-width-windows nil
      large-file-warning-threshold nil
      create-lockfiles nil)
#+END_SRC

*** Enable every disabled command

I just don't want to be prompted about disabled commands

#+BEGIN_SRC emacs-lisp
(setq disabled-command-function nil)
#+END_SRC

*** UTF-8 everywhere please

UTF-8 everything. Taken from [[http://stackoverflow.com/questions/2901541/which-coding-system-should-i-use-in-emacs][this answer]].

#+BEGIN_SRC emacs-lisp
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-language-environment 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(setq locale-coding-system 'utf-8)

#+END_SRC

*** Package sources

#+BEGIN_SRC emacs-lisp
(add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)
(unless (assoc-default "melpa" package-archives)
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
  (add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/") t))

(unless package-archive-contents
  (package-refresh-contents))
#+END_SRC

There are some packages that are not available on [[http://melpa.org][melpa]], add [[https://marmalade-repo.org/][marmalade]] for them.

*** Setup load path and use-package

I want to load packages outside of the package system, so I put them in
=~/.emacs.d/elisp=.

Read about [[https://github.com/jwiegley/use-package][use-package]].

Also install =auto-compile= mode so it byte-compile our init file

#+BEGIN_SRC emacs-lisp
(defvar my/elisp-dir (expand-file-name "elisp/" user-emacs-directory))
(defvar my/history-dir (expand-file-name "history/" user-emacs-directory))

(let ((default-directory my/elisp-dir))
  (normal-top-level-add-to-load-path '("."))
  (normal-top-level-add-subdirs-to-load-path))

(unless (package-installed-p 'use-package)
  (package-install 'use-package))
(unless (package-installed-p 'dash)
  (package-install 'dash))

(setq use-package-verbose t
      use-package-always-ensure t)

(require 'use-package)

(use-package auto-compile
  :init
  (progn
    (auto-compile-on-save-mode)
    (auto-compile-on-load-mode)
    (setq auto-compile-display-buffer nil
          auto-compile-mode-line-counter t)))

(setq load-prefer-newer t)
#+END_SRC

*** Fix Emacs Interaction with OS X and $PATH

Some Emacs commands don't work properly on OS X, this fixes it.

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :ensure t
  :pin melpa-stable
  :init
  (progn
    (setq exec-path-from-shell-variables '("PATH" "MANPATH" "LANG" "BROWSER"))
    (exec-path-from-shell-initialize)))
#+END_SRC

*** Use Bash as the default shell

I use Zsh as my default shell and Emacs doesn't like that.

#+BEGIN_SRC emacs-lisp
(setq shell-file-name "/bin/bash")
#+END_SRC

*** Use Bash as the default remote shell

#+BEGIN_SRC emacs-lisp
(setq explicit-shell-file-name "/bin/bash")
#+END_SRC

*** Use Org-mode for *scratch*

#+BEGIN_SRC emacs-lisp
(setq initial-major-mode 'org-mode)
#+END_SRC

** History And Session Configuration
*** Backups

I prefer to have all Emacs history files under one directory
(=~/emacs.d/history/=).

Emacs by default saves backup files in the current directory. Cluttering your
directory with files ending with =~=, this stashes them away in
=~/emacs.d/history/backups/=

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist (list (cons "."  (concat my/history-dir "backups"))))
#+END_SRC

And save lots.

#+BEGIN_SRC emacs-lisp
(setq delete-old-versions -1)
(setq version-control t)
(setq vc-make-backup-files t)
(setq auto-save-file-name-transforms (list (list ".*" (concat my/history-dir "auto-save-list/") t)))
(setq auto-save-list-file-prefix (concat my/history-dir "auto-save-list/saves-"))
#+END_SRC

*** Session history

This saves our position in files other things between Emacs sessions.

#+BEGIN_SRC emacs-lisp
(setq savehist-file (concat my/history-dir "savehist")
      history-length t
      history-delete-duplicates t
      savehist-save-minibuffer-history 1
      savehist-additional-variables '(kill-ring
                                      search-ring
                                      regex-search-ring
                                      extended-command-history)
      save-place-file (concat my/history-dir "saveplace"))
(savehist-mode 1)

#+END_SRC

*** Recentf

Remembers visited files.

#+BEGIN_SRC emacs-lisp
(setq recentf-auto-cleanup 'never
      recentf-max-saved-items 100
      recentf-save-file (concat my/history-dir "recentf"))

(recentf-mode 1)
#+END_SRC

*** Bookmarks File

#+BEGIN_SRC emacs-lisp
(setq bookmark-default-file (concat my/history-dir "bookmarks"))
#+END_SRC

*** Eshell History File

#+BEGIN_SRC emacs-lisp
(setq eshell-history-file-name (concat my/history-dir "eshell/history"))
#+END_SRC

*** Misc history files

These files show up in my =.emacs.d=, so lets stick them in the history file

#+BEGIN_SRC emacs-lisp
(setq image-dired-dir (concat my/history-dir "image-dired/"))
#+END_SRC

** Emacs General Configuration
*** Load customization

#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "customization.el" user-emacs-directory))
(load custom-file)

#+END_SRC

*** Start Emacs server

#+BEGIN_SRC emacs-lisp
(server-start)
#+END_SRC

*** Don't ask when I kill a buffer that has a process running

#+BEGIN_SRC emacs-lisp
(setq kill-buffer-query-functions
      (remq 'process-kill-buffer-query-function
            kill-buffer-query-functions))
#+END_SRC

*** Allows Emacs to open compressed files and compresses them back when you save the file.

#+BEGIN_SRC emacs-lisp
(auto-compression-mode t)
#+END_SRC

*** Set the cursor to be a line

#+BEGIN_SRC emacs-lisp
(setq-default cursor-type 'bar)
#+END_SRC

*** Highlight matching parentheses when the cursor is on them.

#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
#+END_SRC

*** Don't use tabs for indentation.

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

*** Set tab width

#+BEGIN_SRC emacs-lisp
(setq-default tab-width 2)
#+END_SRC

*** Highlight the current line

#+BEGIN_SRC emacs-lisp
(global-hl-line-mode)
#+END_SRC

*** Add newline at the end of the file

#+BEGIN_SRC emacs-lisp
(setq-default require-final-newline t)
#+END_SRC

*** Disable =magic-mode=

#+BEGIN_SRC emacs-lisp
(setq magic-mode-alist nil)
#+END_SRC

*** Show column number

#+BEGIN_SRC emacs-lisp
(column-number-mode)
#+END_SRC

*** Enable subword mode

#+BEGIN_SRC emacs-lisp
(subword-mode t)
#+END_SRC

*** Sentence end

Sentence end with only one space.

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

*** Change "yes or no" to "y or n"

I'm lazy okay?

#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Use system trash instead of using =rm=

I =trash= command installed from homebrew, this makes files deleted from Emacs go
to the Trash folder.

#+BEGIN_SRC emacs-lisp
(defalias 'move-file-to-trash 'system-move-file-to-trash)

(defun system-move-file-to-trash (file)
  "Use \"trash\" to move FILE to the system trash"
  (call-process (executable-find "trash") nil 0 nil file))

#+END_SRC

*** Set the default browser

#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'browse-url-chromium
      browse-url-chromium-program "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome")
#+END_SRC

*** Tramp

Allow to sudo edit files on trqeem.com

#+BEGIN_SRC emacs-lisp
(use-package tramp
  :defer t
  :config
  (setq tramp-persistency-file-name (concat my/history-dir "tramp"))
  (setq tramp-process-connection-type nil
        tramp-default-method "scpx"
        vc-ignore-dir-regexp (format "\\(%s\\)\\|\\(%s\\)"
                                     vc-ignore-dir-regexp
                                     tramp-file-name-regexp)))
#+END_SRC

*** Calc

It's so much easier to hit =8= than =*=.

#+BEGIN_SRC emacs-lisp
(bind-keys* ("C-x 8 q" . quick-calc))
#+END_SRC

*** Switch back to Terminal.app after emacsclient

When I call emacsclient I'm definitely on Terminal.app

#+BEGIN_SRC emacs-lisp
(defun focus-terminal ()
  ;; Don't switch if we are committing to git
  (unless (or (get-buffer "COMMIT_EDITMSG")
              (get-buffer "git-rebase-todo"))
    (do-applescript "tell application \"Terminal\" to activate")))

(add-hook 'server-done-hook #'focus-terminal)
#+END_SRC

*** Emacs Client

I want =C-c C-c= to end the editing session.

#+BEGIN_SRC emacs-lisp
(add-hook 'server-visit-hook
          (lambda ()
            (local-set-key (kbd "C-c C-c") 'server-edit)))
#+END_SRC

*** Override Emacs keybinding
**** Unbinding

Unbinding these keys because they are used for something else

#+BEGIN_SRC emacs-lisp
(unbind-key "C-;")
(unbind-key "C-x m")
;;(unbind-key "C-;" flyspell-mode-map)
#+END_SRC

**** Bindings

These are my personal preference to the default Emacs keybindings.

#+BEGIN_SRC emacs-lisp
(bind-keys ("C-s" . isearch-forward-regexp)
           ("C-r" . isearch-backward-regexp)
           ("C-M-s" . isearch-forward)
           ("C-M-r" . isearch-backward)
           ("C-h a" . apropos)
           ("C-w" . backward-kill-word)
           ("C-x C-k" . kill-region)
           ("M-/" . hippie-expand)
           ("RET" . reindent-then-newline-and-indent)
           ("C-x t l" . toggle-truncate-lines)
           ("C-<tab>" . indent-for-tab-command)
           ("C-x s" . save-buffer))
#+END_SRC

**** Window movement

Use =Shift-Arrows= to move between windows

#+BEGIN_SRC emacs-lisp
(windmove-default-keybindings)

(defun my/switch-window-forward ()
  (interactive)
  (other-window 1))

(defun my/switch-window-backward ()
  (interactive)
  (other-window -1))

(bind-keys ("C-x o" . my/switch-window-backward)
           ("C-x C-o" . my/switch-window-forward))


#+END_SRC

**** Quickly switch to previous buffer

#+BEGIN_SRC emacs-lisp
(bind-key "M-`" 'my/previous-buffer)

(defun my/previous-buffer ()
  (interactive)
  (switch-to-buffer (other-buffer (current-buffer) 1)))
#+END_SRC

**** Window splitting

Copied from http://www.reddit.com/r/emacs/comments/25v0eo/you_emacs_tips_and_tricks/chldury
#+BEGIN_SRC emacs-lisp
(defun my/vsplit-last-buffer (prefix)
  "Split the window vertically and display the previous buffer."
  (interactive "p")
  (split-window-vertically)
  (other-window 1 nil)
  (if (= prefix 1) (switch-to-next-buffer)))

(defun my/hsplit-last-buffer (prefix)
  "Split the window horizontally and display the previous buffer."
  (interactive "p")
  (split-window-horizontally)
  (other-window 1 nil)
  (if (= prefix 1) (switch-to-next-buffer)))

(bind-key "C-x 2" 'my/vsplit-last-buffer)
(bind-key "C-x 3" 'my/hsplit-last-buffer)
#+END_SRC

**** Eshell

#+BEGIN_SRC emacs-lisp
(setq eshell-glob-case-insensitive t
      eshell-cmpl-ignore-case t)
#+END_SRC

** Appearance Configuration
*** Window configuration

I rarely, if ever, use the mouse in Emacs. This disable the GUI elements

#+BEGIN_SRC emacs-lisp
(when window-system
  (tooltip-mode -1)
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1))

#+END_SRC

Don't ever use GUI dialog boxes

#+BEGIN_SRC emacs-lisp
(setq use-dialog-box nil)

#+END_SRC

Resize Emacs window (called frame in Emacs jargon) as pixels instead of chars resulting in fully sized window.

#+BEGIN_SRC emacs-lisp
(setq frame-resize-pixelwise t)
#+END_SRC

Remember cursor position when scrolling

#+BEGIN_SRC emacs-lisp
(setq scroll-preserve-screen-position 'always)
#+END_SRC

Add a bigger offset to underline property (it makes smart-mode-line looks way nicer)

#+BEGIN_SRC emacs-lisp
(setq underline-minimum-offset 4)
#+END_SRC

*** Fonts and colors
**** Default font
#+BEGIN_SRC emacs-lisp
(set-face-attribute 'default nil
                    :foreground "#819090"
                    :slant 'normal
                    :weight 'normal
                    :height 120
                    :width 'normal
                    :family "Menlo")
#+END_SRC

**** Echo Area

#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(echo-area ((t (:stipple nil :strike-through nil :underline nil :slant normal :weight normal :height 120 :width normal :family "Menlo"))) t))
#+END_SRC

**** Font lock faces

#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(font-lock-builtin-face ((t (:foreground "#6193B3" :weight bold))))
 '(font-lock-comment-face ((t (:foreground "#53686f" :inverse-video nil :underline nil :slant italic :weight normal))))
 '(font-lock-constant-face ((t (:foreground "DeepSkyBlue3"))))
 '(font-lock-function-name-face ((t (:weight bold)))))

#+END_SRC

**** Highlight color

#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(highlight ((t (:background "#1c4c5e")))))
#+END_SRC

**** Region color

#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(region ((t (:background "#175062" :foreground nil)))))


#+END_SRC

**** Minibuffer

#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(minibuffer-prompt ((t (:foreground "#2076c8" :inverse-video nil :underline nil :slant normal :weight bold)))))
#+END_SRC

**** Parentheses match

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'show-paren-match nil
                    :background "#0a2832"
                    :foreground "#c71b6f"
                    :inverse-video nil :underline nil
                    :slant 'normal
                    :weight 'bold)

#+END_SRC

**** Variable pitch mode

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'variable-pitch nil
                    :height 110
                    :width 'normal
                    :font "Kawkab Mono Bold")

(bind-key "C-x t v"  'variable-pitch-mode)
#+END_SRC

*** Smart Mode Line

Compact mode line

#+BEGIN_SRC emacs-lisp
(use-package smart-mode-line
  :ensure t
  :pin melpa-stable
  :init
  (progn
    (setq sml/no-confirm-load-theme t)
    (setq  sml/replacer-regexp-list '(("^~/Dropbox/Code/ruby/rails/" ":Code:Rails:")
                                      ("^~/Dropbox/Code/org/" ":Org:")
                                      ("^~/\\.emacs\\.d/" ":ED:")
                                      ("^/sudo:.*:" ":SU:")
                                      ("^~/Documents/" ":Doc:")
                                      ("^~/Dropbox/" ":DB:")
                                      ("^:\\([^:]*\\):Documento?s/" ":\\1/Doc:")
                                      ("^~/[Gg]it/" ":Git:")
                                      ("^~/[Gg]it[Hh]ub/" ":Git:")
                                      ("^~/[Gg]it\\([Hh]ub\\|\\)-?[Pp]rojects/" ":Git:")
                                      ("^~/Downloads/" ":DWN:")
                                      ("^~/Dropbox/Code/" ":Code:")
                                      ("^~/Dropbox/Code/gh/" ":Git:"))
           sml/shorten-directory t
           sml/show-file-name t
           sml/theme 'respectful)
    (sml/setup)))
#+END_SRC

*** Set up Solarized color theme

Solarized is so good.

#+BEGIN_SRC emacs-lisp
(use-package solarized-theme
  :ensure t
  :pin melpa-stable
  :config
  (progn
    (setq solarized-scale-org-headlines nil)
    (load-theme 'solarized-dark)))
#+END_SRC

*** Rainbow Delimiters

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :pin melpa-stable
  :init
  (progn
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
    (add-hook 'emacs-lisp-mode-hook #'rainbow-delimiters-mode)
    (add-hook 'org-mode-hook #'rainbow-delimiters-mode)
    (add-hook 'markdown-mode-hook #'rainbow-delimiters-mode)
    (setq rainbow-delimiters-max-face-count 1)))

#+END_SRC

Appearance

#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(rainbow-delimiters-depth-1-face ((t (:foreground "#A52E66"))))
 '(rainbow-delimiters-depth-3-face ((t (:foreground "#384311"))))
 '(rainbow-delimiters-depth-4-face ((t (:foreground "#384311"))))
 '(rainbow-delimiters-depth-5-face ((t (:foreground "#384311"))))
 '(rainbow-delimiters-depth-6-face ((t (:foreground "#384311"))))
 '(rainbow-delimiters-depth-7-face ((t (:foreground "#384311"))))
 '(rainbow-delimiters-depth-8-face ((t (:foreground "#384311"))))
 '(rainbow-delimiters-depth-9-face ((t (:inherit rainbow-delimiters-depth-1-face :foreground "#384311"))))
 '(rainbow-delimiters-unmatched-face ((t (:foreground "#d11a24")))))

#+END_SRC

*** Highlight the current line

#+BEGIN_SRC emacs-lisp
(global-hl-line-mode t)
#+END_SRC

*** Prettify symbols

Automatically transform symbols like lambda into the greek letter =λ=

#+BEGIN_SRC emacs-lisp
(global-prettify-symbols-mode t)
#+END_SRC

*** Set Fringe Mode to 1 pixels and remove newline indicators

#+BEGIN_SRC emacs-lisp
(set-fringe-mode 1)
#+END_SRC


** Mode Configuration
*** Pin Depencies to stable versions

#+BEGIN_SRC emacs-lisp
(let ((packages '((async . "melpa-stable")
                  (dash . "melpa-stable")
                  (diminish . "melpa-stable")
                  (epl . "melpa-stable")
                  (f . "melpa-stable")
                  (git-commit . "melpa-stable")
                  (helm-c-yasnippet . "melpa-stable")
                  (helm-core . "melpa-stable")
                  (hydra . "melpa-stable")
                  (inflections . "melpa-stable")
                  (logito . "melpa-stable")
                  (makey . "melpa-stable")
                  (names . "melpa-stable")
                  (packed . "melpa-stable")
                  (pcache . "melpa-stable")
                  (pkg-info . "melpa-stable")
                  (popup . "melpa-stable")
                  (rich-minority . "melpa-stable")
                  (s . "melpa-stable")
                  (use-package . "melpa-stable")
                  (with-editor . "melpa-stable"))))
  (mapcar (lambda (package)
            (add-to-list 'package-pinned-packages package))
          packages))
#+END_SRC

*** Helm - Interactive completion

Helm is awesome, read this [[http://tuhdo.github.io/helm-intro.html][blog]] post to learn about it.

#+BEGIN_SRC emacs-lisp
(use-package helm
  :ensure t
  :init
  (progn
    (require 'helm-config)
    (setq helm-command-prefix-key "C-c h"
          helm-candidate-number-limit 200
          helm-idle-delay 0.0
          helm-input-idle-delay 0.01
          helm-quick-update t
          helm-buffers-fuzzy-matching t
          helm-google-suggest-use-curl-p t
          helm-move-to-line-cycle-in-source nil
          helm-scroll-amount 4
          helm-split-window-default-side 'other
          helm-split-window-in-side-p t
          ido-use-virtual-buffers t     ; FIXME
          helm-M-x-requires-pattern 0
          helm-ff-skip-boring-files t
          helm-ff-file-name-history-use-recentf t
          helm-ack-auto-set-filetype t
          helm-adaptive-history-file (concat my/history-dir
                                             "helm-adaptive-history")
          helm-autoresize-max-height 30
          helm-autoresize-min-height 30
          helm-boring-file-regexp-list '("\\.DS_STORE$" "\\.keep$"
                                         "\\.o$" "~$" "\\.bin$" "\\.lbin$"
                                         "\\.so$" "\\.a$" "\\.ln$" "\\.blg$"
                                         "\\.bbl$" "\\.elc$" "\\.lof$" "\\.glo$"
                                         "\\.idx$" "\\.lot$" "\\.svn$" "\\.hg$"
                                         "\\.git$" "\\.bzr$" "CVS$" "_darcs$"
                                         "_MTN$" "\\.fmt$" "\\.tfm$" "\\.class$"
                                         "\\.fas$" "\\.lib$" "\\.mem$" "\\.x86f$"
                                         "\\.sparcf$" "\\.dfsl$" "\\.pfsl$"
                                         "\\.d64fsl$" "\\.p64fsl$" "\\.lx64fsl$"
                                         "\\.lx32fsl$" "\\.dx64fsl$" "\\.dx32fsl$"
                                         "\\.fx64fsl$" "\\.fx32fsl$" "\\.sx64fsl$"
                                         "\\.sx32fsl$" "\\.wx64fsl$" "\\.wx32fsl$"
                                         "\\.fasl$" "\\.ufsl$" "\\.fsl$" "\\.dxl$"
                                         "\\.lo$" "\\.la$" "\\.gmo$" "\\.mo$"
                                         "\\.toc$" "\\.aux$" "\\.cp$" "\\.fn$"
                                         "\\.ky$" "\\.pg$" "\\.tp$" "\\.vr$"
                                         "\\.cps$" "\\.fns$" "\\.kys$" "\\.pgs$"
                                         "\\.tps$" "\\.vrs$" "\\.pyc$" "\\.pyo$"
                                         "\\.dropbox$" "\\.CFUserTextEncoding")
          helm-external-programs-associations '(("html" . "open"))
          helm-ff-newfile-prompt-p nil
          helm-ff-skip-boring-files t
          helm-input-method-verbose-flag nil
          helm-mode-reverse-history t
          helm-truncate-lines t
          helm-ff-search-library-in-sexp t)
    (helm-mode))
  :bind (("C-x C-m" . helm-M-x)
         ("C-x m" . helm-M-x)
         ("C-x b" . helm-buffers-list)
         ("C-x C-b" . helm-buffers-list)
         ("C-x C-f" . helm-find-files)
         ("C-x C-i" . helm-semantic-or-imenu)
         ("C-c s" . helm-do-ag)
         ("M-y" . helm-show-kill-ring))
  :config
  (progn
    (setq helm-buffers-favorite-modes (append helm-buffers-favorite-modes
                                              '(picture-mode)))
    (helm-autoresize-mode t)
    (bind-keys :map helm-map
               ("<tab>" . helm-execute-persistent-action)
               ("C-<tab>" . helm-execute-persistent-action)
               ("C-i" . helm-execute-persistent-action)
               ("C-z" . helm-select-action)
               ("C-w" . nil))
    (bind-keys :map helm-grep-mode-map
               ("<return>" . helm-grep-mode-jump-other-window)
               ("n" . helm-grep-mode-jump-other-window-forward)
               ("p" . helm-grep-mode-jump-other-window-backward))
    ;; Disable input-method inheritance inside helm buffers
    (add-hook 'helm-before-initialize-hook (lambda ()
                                             (helm-set-local-variable
                                              'current-input-method nil)))
    (add-hook 'helm-goto-line-before-hook 'helm-save-current-pos-to-mark-ring)))
#+END_SRC

I much prefer helm's live grep over regular =helm-do-grep=

#+BEGIN_SRC emacs-lisp
(defun my/helm-do-grep (args)
  (interactive "P")
  (let ((current-prefix-arg '(4)))
    (helm-do-grep)))
#+END_SRC

Use helm for =desribe-binding= and =where-is=

#+BEGIN_SRC emacs-lisp
(use-package helm-descbinds
  :ensure t
  :pin melpa-stable
  :defer t
  :bind (("C-h b" . helm-descbinds)
         ("C-h w" . helm-descbinds)))
#+END_SRC

Replace isearch =C-r= with [[https://github.com/ShingoFukuyama/helm-swoop][helm-swoop]]

#+begin_src emacs-lisp
(use-package helm-swoop
  :ensure t
  :pin melpa-stable
  :bind ("C-M-r" . helm-swoop))
#+end_src

#+BEGIN_SRC emacs-lisp
(use-package helm-ag
  :ensure t
  :pin melpa-stable)
#+END_SRC

Appearance

#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(helm-buffer-file ((t (:inherit font-lock-constant-face))))
 '(helm-ff-directory ((t (:foreground "#2076c8"))))
 '(helm-ff-dotted-directory ((t (:foreground "#2778C5"))))
 '(helm-ff-executable ((t (:foreground "#a67721"))))
 '(helm-ff-file ((t (:inherit default))))
 '(helm-ff-symlink ((t (:foreground "#259185"))))
 '(helm-match ((t (:foreground "#a67721"))))
 '(helm-selection ((t (:background "#0f3f4e" :underline t))))
 '(helm-selection-line ((t (:background "#0f3f4e"))))
 '(helm-source-header ((t (:background "#22083397778B" :foreground "white" :weight extra-bold :height 1.3 :family "Sans Serif"))))
 '(helm-visible-mark ((t (:background "#4d5b17")))))

#+END_SRC

*** Projectile

Projectile mode is one the best packages Emacs have, more information is in this
[[http://tuhdo.github.io/helm-projectile.html][blog]] post.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :pin melpa-stable
  :bind ("C-c C-p" . projectile-command-map)
  :init
  (progn
    (setq projectile-enable-caching t
          projectile-cache-file (concat my/history-dir
                                        "projectile.cache")
          projectile-completion-system 'helm
          projectile-enable-caching t
          projectile-file-exists-remote-cache-expire nil
          projectile-known-projects-file (concat my/history-dir
                                                 "projectile-bookmarks.eld")
          projectile-mode-line nil
          projectile-remember-window-configs nil)
    (projectile-global-mode)
    (projectile-load-known-projects)))
#+END_SRC

Helm + Projectile = Love

#+BEGIN_SRC emacs-lisp
(use-package helm-projectile
  :ensure t
  :pin melpa-stable
  :init
  (progn
    (helm-projectile-on)
    (setq helm-projectile-fuzzy-match nil)))

#+END_SRC

*** Projectile Rails

Extension to Projectile for navigating Rails files.

#+BEGIN_SRC emacs-lisp
(use-package projectile-rails
  :ensure t
  :pin melpa-stable
  :commands projectile-rails-on
  :config
  (progn
    (setq
     projectile-rails-font-lock-face-name 'font-lock-builtin-face
     projectile-rails-stylesheet-re "\\.scss\\'"
     projectile-rails-javascript-re "\\.js\\(?:\\.\\(?:coffee\\|ts\\)\\)?\\'"
     projectile-rails-resource-name-re-list
     `("/app/models/\\(?:.+/\\)?\\(.+\\)\\.rb\\'"
       "/app/controllers/\\(?:.+/\\)?\\(.+\\)_controller\\.rb\\'"
       "/app/views/\\(?:.+/\\)?\\([^/]+\\)/[^/]+\\'"
       "/app/helpers/\\(?:.+/\\)?\\(.+\\)_helper\\.rb\\'"
       ,(concat "/app/assets/javascripts/\\(?:.+/\\)?\\(.+\\)" projectile-rails-javascript-re)
       ,(concat "/app/assets/stylesheets/\\(?:.+/\\)?\\(.+\\)" projectile-rails-stylesheet-re)
       "/db/migrate/.*create_\\(.+\\)\\.rb\\'"
       "/spec/.*/\\([a-z_]+?\\)\\(?:_controller\\)?_spec\\.rb\\'"
       "/\\(?:test\\|spec\\)/\\(?:fixtures\\|factories\\|fabricators\\)/\\(.+?\\)\\(?:_fabricator\\)?\\.\\(?:yml\\|rb\\)\\'"))
    (set-face-attribute 'projectile-rails-keyword-face nil
                        :inherit 'font-lock-builtin-face)))
#+END_SRC

*** Smartparens mode

This package manages pairs for you, so if you insert =(= it automatically inserts
the closing pair.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :ensure t
  :pin melpa-stable
  :init
  (progn
    (require 'smartparens-config)
    (bind-keys :map sp-keymap
               ("C-M-f" . sp-forward-sexp)
               ("C-M-b" . sp-backward-sexp)
               ("C-M-d" . sp-down-sexp)
               ("C-M-a" . my/sp-begging-of-sexp)
               ("C-M-e" . my/sp-end-of-sexp)
               ("C-S-a" . sp-beginning-of-sexp)
               ("C-S-d" . sp-end-of-sexp)
               ("C-M-u" . sp-backward-up-sexp)
               ("C-M-t" . sp-transpose-sexp)
               ("C-M-n" . sp-next-sexp)
               ("C-M-p" . sp-previous-sexp)
               ("C-M-k" . sp-kill-sexp)
               ("C-M-w" . sp-copy-sexp)
               ("M-<backspace>" . sp-unwrap-sexp)
               ("M-<delete>" . sp-backward-unwrap-sexp)
               ("M-." . sp-forward-slurp-sexp)
               ("M-," . sp-forward-barf-sexp)
               ("C-M-<left>" . sp-backward-slurp-sexp)
               ("C-M-<right>" . sp-backward-barf-sexp)
               ("C-M-<delete>" . sp-splice-sexp-killing-forward)
               ("C-M-<backspace>" . sp-splice-sexp-killing-backward)
               ("C-S-<backspace>" . sp-splice-sexp-killing-around)
               ("C-]" . sp-select-next-thing-exchange)
               ("C-<left_bracket>" . sp-select-previous-thing)
               ("C-M-]" . sp-select-next-thing)
               ("M-F" . sp-forward-symbol)
               ("M-B" . sp-backward-symbol)
               ("H-t" . sp-prefix-tag-object)
               ("H-p" . sp-prefix-pair-object)
               ("H-s c" . sp-convolute-sexp)
               ("H-s a" . sp-absorb-sexp)
               ("H-s e" . sp-emit-sexp)
               ("H-s p" . sp-add-to-previous-sexp)
               ("H-s n" . sp-add-to-next-sexp)
               ("H-s j" . sp-join-sexp)
               ("H-s s" . sp-split-sexp))
    (smartparens-global-mode t)
    (show-smartparens-global-mode t)
    (show-paren-mode -1)))

(defun my/sp-begging-of-sexp ()
  (interactive)
  (let ((beginning (sp-get (sp-get-enclosing-sexp) :beg)))
    (if (and beginning (= (- (point) 1) beginning))
        (goto-char beginning)
      (sp-beginning-of-sexp))))

(defun my/sp-end-of-sexp ()
  (interactive)
  (let ((end (sp-get (sp-get-enclosing-sexp) :end)))
    (if (and end (= (+ (point) 1) end))
        (goto-char end)
      (sp-end-of-sexp))))
#+END_SRC


Appearance

#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(sp-show-pair-match-face ((t (:foreground "#d73182"))))
 '(sp-show-pair-mismatch-face ((t (:background "#810160")))))

(setq sp-highlight-pair-overlay nil
      sp-highlight-wrap-overlay nil
      sp-highlight-wrap-tag-overlay nil)
#+END_SRC

*** Magit

Better interface to Git

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :pin melpa-stable
  :defer t
  :commands magit-status
  :bind ("C-c <return>" . magit-status)
  :config
  (use-package magit-popup
    :pin melpa-stable)
  (progn
    (setq magit-push-always-verify nil
          magit-revert-buffers 'silent)
    (fullframe magit-status magit-mode-quit-window nil)
    (custom-set-faces
     '(magit-blame-date ((t (:foreground "#D13A82" :background "#2D393D"))))
     '(magit-blame-hash ((t (:foreground "#C4A449" :background "#2D393D"))))
     '(magit-blame-heading ((t (:foreground "#D13A82" :background "#2D393D"))))
     '(magit-blame-summary ((t (:foreground "#2D8CD0" :background "#2D393D"))))
     '(magit-blame-name ((t (:foreground "#C4A449" :background "#2D393D")))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package fullframe
  :ensure t
  :pin melpa-stable)
#+END_SRC

Set the visibility of the =Unmerged into upstream= section to always be hidden, see [[http://emacs.stackexchange.com/questions/20754/change-the-default-visibility-of-a-magit-section/20767][this stackexchange question]].


#+BEGIN_SRC emacs-lisp
(defun my/magit-initially-hide-unmerged (section)
  (and (not magit-insert-section--oldroot)
       (eq (magit-section-type section) 'unpushed)
       (equal (magit-section-value section) "@{upstream}..")
       'hide))

(add-hook 'magit-section-set-visibility-hook 'my/magit-initially-hide-unmerged)
#+END_SRC

*** Git timemachien

Timemachine like interface for git

#+BEGIN_SRC emacs-lisp
  (use-package git-timemachine
    :ensure t
    :pin melpa-stable)
#+END_SRC

*** Company Mode

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :pin melpa-stable
  :init
  (progn
    (global-company-mode)
    (bind-keys :map company-active-map
               ("C-w" . my/company-abort))
    (push 'company-robe company-backends)
    (add-to-list 'company-dabbrev-code-modes 'ruby-mode)
    (setq company-global-modes '(not inf-ruby-mode eshell-mode)
          company-idle-delay 0.3
          company-minimum-prefix-length 3
          company-dabbrev-downcase nil
          company-backends '(company-robe
                             company-bbdb
                             company-nxml
                             company-css
                             company-eclim
                             company-semantic
                             company-clang
                             company-xcode
                             company-cmake
                             company-capf
                             (company-dabbrev-code company-keywords)
                             company-oddmuse
                             company-files
                             company-dabbrev))))
#+END_SRC


#+BEGIN_SRC emacs-lisp
(defun my/company-abort ()
  (interactive)
  (company-abort)
  (execute-kbd-macro (kbd "C-w")))
#+END_SRC

Company Appearance

#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(company-preview ((t (:foreground "wheat"))))
 '(company-preview-common ((t (:inherit company-preview :foreground "#465b62"))))
 '(company-scrollbar-bg ((t (:inherit company-tooltip :background "#092832"))))
 '(company-scrollbar-fg ((t (:background "#eae3cc"))))
 '(company-tooltip ((t (:background "#13394c" :foreground "#839496"))))
 '(company-tooltip-common ((t (:inherit company-tooltip :foreground "#821117"))))
 '(company-tooltip-common-selection ((t (:inherit company-tooltip-selection :foreground "#d11a24"))))
 '(company-tooltip-selection ((t (:inherit company-tooltip :background "#022028")))))
#+END_SRC

*** Winner

Winner mode gives you the ability to undo and redo your window configuration, watch
this [[https://www.youtube.com/watch?v%3DT_voB16QxW0][video]] for better explanation.

#+BEGIN_SRC emacs-lisp
(use-package winner
  :init (winner-mode 1))
#+END_SRC

*** Discover Major Mode keybindings

#+BEGIN_SRC emacs-lisp
(use-package discover-my-major
  :ensure t
  :pin melpa-stable
  :defer t
  :commands discover-my-major
  :bind ("C-h C-m" . discover-my-major))
#+END_SRC

*** Multiple Cursors

As the name suggest, it allows editing over multiple lines

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :pin melpa-stable
  :ensure t
  :bind (("C-c SPC" . mc/edit-lines)
         ("M-]" . mc/mark-next-like-this)
         ("M-[" . mc/mark-previous-like-this)
         ("M-}" . mc/unmark-next-like-this)
         ("M-{" . mc/unmark-previous-like-this)
         ("C-M-SPC" . set-rectangular-region-anchor))
  :config
  (setq mc/list-file (concat my/history-dir "mc-lists.el")))
#+END_SRC

*** Abbrev mode

Useful for defining abbreviations

#+BEGIN_SRC emacs-lisp
(setq save-abbrevs t)
(setq-default abbrev-mode t)
(setq abbrev-file-name (concat my/history-dir "abbrev_defs"))
#+END_SRC

*** Paradox

A better alternative to =package-list-packages=

#+BEGIN_SRC emacs-lisp
(use-package paradox
  :ensure t
  :pin melpa-stable
  :config
  (progn
    (defalias 'pkg 'paradox-list-packages)
    (setq paradox-automatically-star t
          paradox-execute-asynchronously t
          paradox-lines-per-entry 1)))


#+END_SRC

*** Ispell

Use hunspell because it's more powerful and supports Arabic.

#+BEGIN_SRC emacs-lisp
(setq ispell-program-name "hunspell"
          ispell-really-hunspell t
          ispell-keep-choices-win t
          ispell-use-framepop-p nil
          speck-hunspell-default-dictionary-name "en_US"
          speck-hunspell-dictionary-alist '(("en" . "en_US") ("ar" . "ar"))
          speck-iso-639-1-alist '(("ar" . "arabic")
                                  ("bg" . "bulgarian")
                                  ("ca" . "catalan")
                                  ("cs" . "czech")
                                  ("da" . "danish")
                                  ("de" . "deutsch")
                                  ("de" . "german")
                                  ("el" . "greek")
                                  ("en" . "english")
                                  ("eo" . "esperanto")
                                  ("es" . "spanish")
                                  ("fi" . "finnish")
                                  ("fr" . "francais")
                                  ("fr" . "french")
                                  ("hu" . "hungarian")
                                  ("it" . "italiano")
                                  ("it" . "italian")
                                  ("la" . "latin")
                                  ("nl" . "dutch")
                                  ("no" . "norwegian")
                                  ("pl" . "polish")
                                  ("pt" . "portuguese")
                                  ("ro" . "romanian")
                                  ("ru" . "russian")
                                  ("sh" . "serbo-croatian")
                                  ("sk" . "slovak")
                                  ("sv" . "swedish")
                                  ("tr" . "turkish")))
#+END_SRC

Use both ispell and abbrev together.

#+BEGIN_SRC emacs-lisp
(defun ispell-word-then-abbrev (p)
  "Call `ispell-word'. Then create an abbrev for the correction made.
With prefix P, create local abbrev. Otherwise it will be global."
  (interactive "P")
  (let ((bef (downcase (or (thing-at-point 'word) ""))) aft)
        (call-interactively 'ispell-word)
        (setq aft (downcase (or (thing-at-point 'word) "")))
        (unless (string= aft bef)
          (message "\"%s\" now expands to \"%s\" %sally"
                   bef aft (if p "loc" "glob"))
          (define-abbrev
        (if p local-abbrev-table global-abbrev-table)
        bef aft))))

(bind-keys ("C-x t i" . ispell-word-then-abbrev))

#+END_SRC

*** Undo Tree

A better undo/redo alternative

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :pin melpa-stable
  :ensure t
  :bind ("C-M-_" . undo-tree-visualize)
  :init
  (global-undo-tree-mode t))
#+END_SRC

*** Avy

Similar to ace-jump above

#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :pin melpa-stable
  :commands avy-goto-word-or-subword-1
  :bind ("C-." . avy-goto-word-or-subword-1)
  :init (setq avy-style 'at)
  :config
  (avy-setup-default))
#+END_SRC

*** Git mode

Appearance

#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(git-commit-mode-default ((t (:height 120 :family "Menlo"))) t))

(add-hook 'git-commit-mode-hook #'flyspell-mode)
#+END_SRC

*** Popwin

Popwin makes popup window awesome again, every popup window can be closed by =C-g=.

#+BEGIN_SRC emacs-lisp
(use-package popwin
  :ensure t
  :pin melpa-stable
  :bind ("C-h e" . popwin:messages)
  :commands (popwin-mode)
  :init
  (progn
    (popwin-mode t)
    (push '("*rspec-compilation*" :tail nil) popwin:special-display-config)
    (push "*projectile-rails-server*" popwin:special-display-config)
    (push "*coffee-compiled*" popwin:special-display-config)
    (push "*Bundler*" popwin:special-display-config)
    (push "*projectile-rails-compilation*" popwin:special-display-config)
    (push "*Ack-and-a-half*" popwin:special-display-config)
    (push '("*ruby*" :height 0.75 :position bottom) popwin:special-display-config)
    (push "*rails*" popwin:special-display-config)
    (push "*Compile-Log*" popwin:special-display-config)
    (push "*pry*" popwin:special-display-config)
    (push "*SQL*" popwin:special-display-config)
    (push "*projectile-rails-generate*" popwin:special-display-config)
    (push "*Package Commit List*" popwin:special-display-config)
    (push "*Compile-Log*" popwin:special-display-config)
    (push '(" *undo-tree*" :position bottom) popwin:special-display-config)
    (push "*compilation*" popwin:special-display-config)
    (push '("RuboCop.*" :regex 't) popwin:special-display-config)
    (push '("*HTTP Response*" :position bottom :height 30) popwin:special-display-config)
    (global-set-key (kbd "C-z") popwin:keymap)))
#+END_SRC

*** Aggressive Indent Mode

#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :ensure t
  :pin melpa-stable
  :config
  (progn
    (add-to-list 'aggressive-indent-dont-indent-if
                 '(and (derived-mode-p 'sgml-mode)
                       (string-match "^[[:space:]]*{%"
                                     (thing-at-point 'line))))))
#+END_SRC

*** Ediff Mode

#+BEGIN_SRC emacs-lisp
(setq ediff-merge-split-window-function 'split-window-vertically
          ediff-split-window-function  'split-window-horizontally
          ediff-window-setup-function 'ediff-setup-windows-plain)

#+END_SRC

#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(ediff-current-diff-C ((t (:background "#41421c"))))
 '(ediff-fine-diff-A ((t (:background "#630813"))))
 '(ediff-fine-diff-B ((t (:background "#0a4c1b" :inverse-video nil)))))
#+END_SRC

*** A better query regexp replace

#+BEGIN_SRC emacs-lisp
(use-package visual-regexp
  :defer t
  :commands qrr
  :config
  (progn
        (defalias 'qrr 'vr/query-replace)))
#+END_SRC

*** Auto revert mode

Whenever a file opened by Emacs changed by an external program, this mode
automatically reload the file

#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode t)
#+END_SRC

*** Whitespace mode

Automatically cleans buffers of useless whitespaces and highlights trailing
whitespaces.

#+BEGIN_SRC emacs-lisp
(global-whitespace-mode t)
(setq whitespace-action '(auto-cleanup)
          whitespace-style '(trailing
                         lines
                         empty
                         space-before-tab
                         indentation
                         space-after-tab)
          whitespace-trailing-regexp "\\([    ]+\\)$")
#+END_SRC

Appearance

#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(whitespace-trailing ((t (:background "#20546d" :foreground "#c60007" :inverse-video nil :underline nil :slant normal :weight bold)))))
#+END_SRC

*** Iedit mode

Iedit lets you mark all occurrences of a word to edit them at the same time.

#+BEGIN_SRC emacs-lisp
(use-package iedit
  :ensure t
  :pin melpa-stable
  :defer t
  :commands iedit-mode
  :bind ("C-;" . iedit-mode))
#+END_SRC

*** Expand region

Expand region to fit the sexp

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t
  :defer t
  :commands er/expand-region
  :bind ("M-2" . er/expand-region))
#+END_SRC

*** Persistent *sractch*

#+BEGIN_SRC emacs-lisp
(use-package persistent-scratch
  :ensure t
  :pin melpa-stable
  :init
  (progn
        (setq persistent-scratch-save-file (concat my/history-dir "persistent-scratch"))
        (persistent-scratch-setup-default)))
#+END_SRC

*** Clone Github projects from Emacs

#+BEGIN_SRC emacs-lisp
(use-package github-clone
  :ensure t
  :pin melpa-stable
  :defer t
  :commands github-clone)
#+END_SRC

*** Feature Mode

#+BEGIN_SRC emacs-lisp
(use-package feature-mode
  :ensure t
  :pin melpa-stable
  :defer t
  :commands feature-mode)
#+END_SRC

*** Dired Mode

#+BEGIN_SRC emacs-lisp
(setq dired-listing-switches "-alh")
(bind-keys :map dired-mode-map
           ("C-l" . dired-up-directory))
#+END_SRC

*** Shell Conf Mode

#+BEGIN_SRC emacs-lisp
(use-package sh-mode
  :ensure nil
  :mode "\\.zsh\\'"
  :interpreter "zsh"
  :init
  (setq-default sh-indentation 2
                sh-basic-offset 2))
#+END_SRC

I use [[https://github.com/sorin-ionescu/prezto][prezto]] and I want to associate zsh files without extension to =sh-mode=

#+BEGIN_SRC emacs-lisp
(add-to-list 'magic-fallback-mode-alist
             '((lambda () (string-match-p ".*prezto.*" (buffer-file-name))) . sh-mode))

#+END_SRC

*** Beacon

Never lose your cursor again

#+BEGIN_SRC emacs-lisp
(use-package beacon
  :ensure t
  :pin melpa-stable
  :defer t
  :init
  (beacon-mode t))
#+END_SRC

*** Restclient

#+BEGIN_SRC emacs-lisp
(use-package restclient
  :defer t
  :commands restclient-mode
  :config
  (progn
    (add-hook 'restclient-response-loaded-hook #'view-mode)))

#+END_SRC


** Writing And Programming Modes

Set the global `fill-column`

#+BEGIN_SRC emacs-lisp
(setq-default fill-column 88)
#+END_SRC

*** Text mode

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook
          (lambda ()
            #'turn-on-auto-fill
            #'turn-on-flyspell
            (my/variable-pitch-mode)
            (setq word-wrap t
                  fill-column 85)))

#+END_SRC

Appearance

#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(text-mode-default ((t (:foreground "#819090" :height 180 :family "Helvetica"))) t))
#+END_SRC

Disable variable pitch mode on =git-commit-mode=

#+BEGIN_SRC emacs-lisp
(defun my/variable-pitch-mode ()
  "run variable pitch mode unless the current mode is `git-commit-mode'"
  (unless (or (get-buffer "COMMIT_EDITMSG")
              (get-buffer "git-rebase-todo"))
    (variable-pitch-mode t)))
#+END_SRC

*** Markdown mode

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :pin melpa-stable
  :defer t
  :init
  (add-hook 'markdown-mode-hook #'projectile-rails-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(markdown-bold-face ((t (:inherit font-lock-variable-name-face :weight extra-bold)))))
#+END_SRC

*** Org Mode

#+BEGIN_SRC emacs-lisp
(setq org-log-done t
      org-adapt-indentation nil
      org-edit-src-content-indentation 0
      org-fontify-whole-heading-line t
      org-pretty-entities t
      org-src-fontify-natively t
      org-src-tab-acts-natively nil
      org-src-window-setup 'current-window
      org-goto-interface 'outline
      org-goto-max-level 10
      org-imenu-depth 5
      org-startup-folded nil)

(add-hook 'org-mode-hook #'toggle-truncate-lines)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(org-todo ((t (:background "#052028" :foreground "#c60007" :inverse-video nil :underline nil :slant normal :weight bold)))))
#+END_SRC

*** Emacs Lisp Mode

#+BEGIN_SRC emacs-lisp
(bind-keys :map emacs-lisp-mode-map
           ("M-." find-function-at-point)
           ("C-x C-e" . eval-dwim))

(add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode)
(add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
(add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)

#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun eval-dwim (args)
  "If invoked with C-u then evaluate and replace the current
expression, otherwise use regular `eval-last-sexp'"
  (interactive "P")
  (if args
          (eval-and-replace)
        (eval-last-sexp nil)))

(defun eval-and-replace ()
  "Replace the preceding sexp with its value."
  (interactive)
  (backward-kill-sexp)
  (condition-case nil
          (prin1 (eval (read (current-kill 0)))
                 (current-buffer))
        (error (message "Invalid expression")
           (insert (current-kill 0)))))
#+END_SRC

*** Ruby Mode

#+BEGIN_SRC emacs-lisp
(use-package ruby-mode
  :mode "\\.rb\\'"
  :interpreter "ruby"
  :init
  (progn
    (setq ruby-indent-level 2
          ruby-insert-encoding-magic-comment nil)
    (font-lock-add-keywords 'ruby-mode      ; Highlight && and || as builtin keywords
                            '(("\\(&&\\|||\\)" . font-lock-builtin-face)))

    (add-hook 'ruby-mode-hook #'inf-ruby-minor-mode)
    (add-hook 'ruby-mode-hook #'subword-mode)
    (add-hook 'ruby-mode-hook
              (lambda ()
                (local-set-key (kbd "RET") 'reindent-then-newline-and-indent)
                (push '("lambda" . 955) prettify-symbols-alist)
                (when (projectile-project-p)
                  (projectile-rails-mode))))


    (use-package inf-ruby
      :ensure t
      :pin melpa-stable
      :defer t
      :commands (inf-ruby-minor-mode ruby-send-block-and-go ruby-send-region-and-go)
      :config
      (progn
        (setq inf-ruby-default-implementation "pry")
        (add-hook 'inf-ruby-mode-hook
                  (lambda ()
                    (company-mode 0)))))

    (use-package robe
      :ensure t
      :pin melpa-stable
      :defer t
      :commands robe-mode)

    (use-package rvm
      :ensure t
      :pin melpa-stable
      :defer t
      :init (rvm-use-default))

    (use-package rake
      :ensure t
      :pin melpa-stable
      :defer t
      :config
      (setq rake-cache-file (concat my/history-dir "rake.cache")
            rake-completion-system 'helm))

    (use-package bundler
      :ensure t
      :pin melpa-stable
      :defer t
      :commands bundle-install
      :config
      (rvm-use-default))

    (use-package rubocop
      :ensure t
      :pin melpa-stable
      :defer t
      :commands (rubocop-check-project rubocop-check-current-file)
      :bind (("C-c r <" . my/rubocop-check-project)
             ("C-c r , " . my/rubocop-check-current-file)))))

#+END_SRC


Override =rubocop= functions so they automatically switch to the compilation buffer

#+BEGIN_SRC emacs-lisp
(defun my/rubocop-check-current-file ()
  (interactive)
  (rubocop-check-current-file)
  (popwin:select-popup-window))

(defun my/rubocop-check-project ()
  (interactive)
  (rubocop-check-project)
  (popwin:select-popup-window))
#+END_SRC

*** Setup rcodetools

rcodetools provide a way to evaulate ruby code inside your buffer. The way it works is you add ~# =>~ after an expression and then run ~xmp~ command and it will insert the result after the comment.

#+BEGIN_SRC emacs-lisp
(use-package rcodetools
  :ensure nil
  :commands xmp
  :bind (:map ruby-mode-map ("C-c C-c" . xmp)))

(defadvice my/comment-dwim (around rct-hack activate)
  "If comment-dwim is successively called, add => mark."
  (if (and (eq major-mode 'ruby-mode)
           (eq last-command 'my/comment-dwim))
      (progn (insert "=>")
             (xmp))
    ad-do-it))

#+END_SRC

*** Yasnippet

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :pin melpa-stable
  :commands yas-global-mode
  :defer 3
  :config
  (progn
    (yas-global-mode)
    (use-package helm-c-yasnippet)))
#+END_SRC

*** SQL Mode

#+BEGIN_SRC emacs-lisp
(add-hook 'sql-interactive-mode-hook
          (lambda ()
                (setq truncate-lines t)))
#+END_SRC

*** Rspec Mode

#+BEGIN_SRC emacs-lisp
(use-package rspec-mode
  :ensure t
  :defer t
  :config
  (progn
    (ad-activate 'rspec-compile)
    (rspec-install-snippets)

    (add-hook 'rspec-compilation-mode-hook (lambda ()
                                             (toggle-truncate-lines -1)))
    (setq rspec-compilation-skip-threshold 2
          rspec-snippets-fg-syntax 'concise
          rspec-use-bundler-when-possible t
          rspec-use-rake-when-possible nil
          compilation-scroll-output t
          rspec-use-rvm t)

    (bind-key "C-c C-," rspec-mode-keymap)))

(defadvice rspec-compile (around rspec-compile-around)
  "Use BASH shell for running the specs because of ZSH issues"
  (let ((shell-file-name "/bin/bash"))
    ad-do-it))
#+END_SRC

*** Compilation Mode

#+BEGIN_SRC emacs-lisp
(add-hook 'compilation-mode-hook (lambda ()
                                   (toggle-truncate-lines 1)))
#+END_SRC

*** HTML mode

#+BEGIN_SRC emacs-lisp
(add-hook 'sgml-mode-hook
          (lambda ()
            (variable-pitch-mode nil)))
#+END_SRC

*** nXML mode

#+BEGIN_SRC emacs-lisp
(add-hook 'nxml-mode-hook
          (lambda ()
            (variable-pitch-mode nil)
            (sp-local-pair 'nxml-mode "<" ">" :actions :rem)))
#+END_SRC

*** HAML mode

#+BEGIN_SRC emacs-lisp
(use-package haml-mode
  :ensure t
  :pin melpa-stable
  :defer t
  :config
  (progn
    (add-hook 'haml-mode-hook
              (lambda ()
                (rspec-mode)
                (projectile-rails-mode)))
    (add-hook 'haml-mode-hook
              (lambda ()
                (local-set-key (kbd "RET") 'newline-and-indent)))))
#+END_SRC

*** Web Mode

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :defer t
  :pin melpa-stable
  :mode ("\\.xml$" "\\.erb$")
  :config
  (progn
    (add-hook 'web-mode-hook #'aggressive-indent-mode)
    (add-hook 'web-mode-hook #'projectile-rails-mode)
    (add-hook 'web-mode-hook #'subword-mode)
    (setq web-mode-css-indent-offset 2
          web-mode-markup-indent-offset 2
          web-mode-code-indent-offset 2
          web-mode-auto-close-style 2)))


#+END_SRC

*** YAML mode

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :ensure t
  :pin melpa-stable
  :defer t
  :config
  (progn
    (add-hook 'yaml-mode-hook
              (lambda ()
                (projectile-rails-mode)
                (local-set-key (kbd "RET") 'newline-and-indent)))))
#+END_SRC

*** CSS Mode

#+BEGIN_SRC emacs-lisp
(add-hook 'css-mode-hook
          (lambda ()
                (setq comment-start "//")
                (setq comment-end "")
                (setq css-indent-offset 2)))
#+END_SRC

*** SCSS Mode

#+BEGIN_SRC emacs-lisp
(use-package scss-mode
  :ensure t
  :pin melpa-stable
  :defer t
  :mode "\\.scss\\.erb$"
  :config
  (progn
        (setq scss-compile-at-save nil)
        (add-hook 'scss-mode-hook #'projectile-rails-mode)))

#+END_SRC

*** Jinja Mode

I edit jinja files with names like =example.conf.j2= so I want Emacs to strip the =.j2= extension and choose the proper major mode

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.j2\\'" ignore t))
#+END_SRC

*** Coffeescript Mode

#+BEGIN_SRC emacs-lisp
(use-package coffee-mode
  :ensure t
  :pin melpa-stable
  :defer t
  :mode "\\.coffee\\.erb$"
  :config
  (progn
    (setq coffee-compile-jump-to-error nil
          coffee-tab-width 2)
    (add-hook 'coffee-mode-hook
              (lambda ()
                (rspec-mode)
                (projectile-rails-mode)))))
#+END_SRC

*** Javascript Mode

#+BEGIN_SRC emacs-lisp
(add-hook 'js-mode-hook
          (lambda ()
            (setq js-indent-level 2)
            (subword-mode t)
            (aggressive-indent-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :ensure t
  :pin melpa-stable
  :defer t
  :mode "\\.js\\'"
  :config
  (progn
    (add-hook 'js2-mode-hook #'projectile-rails-mode)
    (add-hook 'js2-mode-hook #'aggressive-indent-mode)
    (setq js2-global-externs '("jQuery" "$" "_" "d3")
          inferior-js-program-command "node"
          js2-basic-offset 2
          js2-missing-semi-one-line-override t
          js2-bounce-indent-p t)
    (set-face-attribute 'js2-function-param nil
                        :foreground nil
                        :inherit 'font-lock-constant-face)))

#+END_SRC

*** Java Mode

#+BEGIN_SRC emacs-lisp
(add-hook 'java-mode-hook #'subword-mode)
#+END_SRC

*** PHP mode

#+BEGIN_SRC emacs-lisp
(use-package php-mode
  :pin melpa-stable
  :ensure t
  :defer t)
#+END_SRC

*** Lua mode

#+BEGIN_SRC emacs-lisp
(use-package lua-mode
  :pin melpa-stable
  :ensure t
  :defer t
  :config
  (setq lua-indent-level 2)
  (add-hook 'lua-mode-hook #'subword-mode))
#+END_SRC

** Misc Settings
*** OS X specific settings

#+BEGIN_SRC emacs-lisp
(setq ns-alternate-modifier 'super
          ns-command-modifier 'meta
          ns-control-modifier 'control)
#+END_SRC

**** OS X Arabic Keybaord

#+BEGIN_SRC emacs-lisp
(load "arabic-mac")
(setq default-input-method "arabic-mac")
#+END_SRC

**** Emoji

#+BEGIN_SRC emacs-lisp
(set-fontset-font t 'symbol (font-spec :family "Apple Color Emoji") nil 'prepend)
#+END_SRC

*** Incremenet/decrement numbers

#+BEGIN_SRC emacs-lisp
(use-package evil-numbers
  :pin melpa-stable
  :ensure t
  :bind (("M-=" . evil-numbers/inc-at-pt)
         ("M--" . evil-numbers/dec-at-pt)))
#+END_SRC

*** Focus help window on popup

#+BEGIN_SRC emacs-lisp
(setq help-window-select t)
#+END_SRC
*** Newline do what I mean

This I took from somewhere, it insert a space if I do =M-return= between bracket or
parentheses, etc.

#+BEGIN_SRC emacs-lisp
(defun my/newline-dwim ()
  (interactive)
  (let ((break-open-pair (or (and (looking-back "{") (looking-at "}"))
                                 (and (looking-back ">") (looking-at "<"))
                                 (and (looking-back "(") (looking-at ")"))
                                 (and (looking-back "\\[") (looking-at "\\]")))))
        (newline)
        (when break-open-pair
          (save-excursion
        (newline)
        (indent-for-tab-command)))
        (indent-for-tab-command)))

(bind-keys ("M-<return>" . my/newline-dwim))
#+END_SRC

*** Comment do what I mean

Better comments, taken from [[http://www.opensubscriber.com/message/emacs-devel@gnu.org/10971693.html][here]].

#+BEGIN_SRC emacs-lisp
(defun my/comment-dwim (&optional arg)
  "Replacement for the comment-dwim command.
 If no region is selected and current line is not blank and we are not at the end of the line, then comment current line.
 Replaces default behaviour of comment-dwim, when it inserts comment at the end of the line."
  (interactive "*P")
  (comment-normalize-vars)
  (if (and (not (region-active-p))
           (not (looking-at "[ \t]*$")))
      (comment-or-uncomment-region (line-beginning-position) (line-end-position))
    (comment-dwim arg)))

(bind-keys ("M-;" . my/comment-dwim))
#+END_SRC

*** Insert a brace with space between them

This I use when I'm programming Ruby to insert a block (blocks have a space between
the content the bracket).
With 5 as a prefix arguments =C-5 C-{=, it inserts a liquid tag ={%  %}=.

#+BEGIN_SRC emacs-lisp
(defun my/brace-with-space (&optional args)
  (interactive "p")
  (if (= args 5)
      (my/insert-liquid-tag)
    (my/insert-brace)))

(defun my/insert-brace ()
  (execute-kbd-macro "{")
  (insert "  ")
  (backward-char 1))

(defun my/insert-liquid-tag ()
  (execute-kbd-macro "{")
  (insert "%  %")
  (backward-char 2))

(bind-keys ("C-{" . my/brace-with-space))

#+END_SRC

*** Insert an ERB tag

inserts ~<%= | %>~ where the =|= is the cursors

#+BEGIN_SRC emacs-lisp
(defun my/insert-erb (args)
  (interactive "P")
  (if (null args)
      (my/erb-without-equal)
    (my/erb-with-equal)))

(defun my/erb-with-equal ()
  (execute-kbd-macro "<")
  (insert "%  %")
  (backward-char 2))

(defun my/erb-without-equal ()
  (execute-kbd-macro "<")
  (insert "%=  %")
  (backward-char 2))

(bind-keys ("C-<" . my/insert-erb))
#+END_SRC

*** Duplicate line

#+BEGIN_SRC emacs-lisp
(bind-keys ("C-x C-y" . my/duplicate-line))

(defun my/duplicate-line (&optional args)
  "duplicate the current line and while saving the current position"
  (interactive "P")
  (let ((column (current-column))
        (times (prefix-numeric-value args)))
        (while (> times 0)
          (move-beginning-of-line 1)
          (kill-line)
          (yank)
          (open-line 1)
          (next-line 1)
          (yank)
          (move-beginning-of-line 1)
          (forward-char column)
          (setq times (1- times)))))

#+END_SRC

*** Flip colon

#+BEGIN_SRC emacs-lisp
(bind-keys ("C-:" . my/flip-colons))

(defun my/flip-colons ()
  (interactive)
  (let ((word (current-word))
        (bounds (bounds-of-thing-at-point 'symbol)))
        (when (or (s-starts-with-p ":" word) (s-ends-with-p ":" word))
          (delete-region (car bounds) (cdr bounds))
          (if (s-starts-with-p ":" word)
          (insert (s-append ":" (s-chop-prefix ":" word)))
        (insert (s-prepend ":" (s-chop-suffix ":" word)))))))
#+END_SRC

*** Toggle inline braces { ... } to multiline

Toggle inline rule into multiline:

#+BEGIN_SRC css
// from this
h1 { font-size: 30px }

// into this
h1 {
  font-size: 30px;
}
#+END_SRC

#+BEGIN_SRC emacs-lisp
(bind-key "C-x t [" 'my/toggle-brace)

(defun my/toggle-brace ()
  (interactive)
  (let (start)
    (save-excursion
      (while (not (looking-back "{")) (backward-char))
      (setq start (point))
      (my/delete-or-insert-newline)
      (while (not (looking-at "\n? *}")) (forward-char))
      (my/delete-or-insert-newline)
      (indent-region start (line-end-position)))))

(defun my/delete-or-insert-newline ()
  (if (looking-at "\n")
      (progn
        (delete-char 1)
        (just-one-space))
    (insert "\n")))
#+END_SRC

*** Just one space to just no space

I use =just-one-space= all the time to forward delete all spaces, but almost always
what I want is delete all spaces to =point=

#+BEGIN_SRC emacs-lisp
(bind-keys ("M-\\" . just-no-space))

(defun just-no-space ()
  (interactive)
  (re-search-forward "[ \t]+" nil t)
  (replace-match "" nil nil))

#+END_SRC

*** Yank and delete from kill-ring

This is useful when you want to paste sensitive information and do not want it to stay in the =kill-ring= variable. Like pasting a password to =tramp=.

#+BEGIN_SRC emacs-lisp
(bind-keys ("C-M-y" . yank-and-remove-from-killring))

(defun yank-and-remove-from-killring ()
  (interactive)
  (yank)
  (setq kill-ring
        (remove (first kill-ring) kill-ring)))
#+END_SRC

*** Insert Arabic Tatweel Character

بعض الأحيان أحتاج أمـــــــــــد بعض الكلمات

#+BEGIN_SRC emacs-lisp
(bind-keys ("C-x t _" . my/insert-tatweel))

(defun my/insert-tatweel (arg)
  (interactive "P")
  (insert-char #x0640 arg))
#+END_SRC

*** Indent buffer

Taken from [[https://github.com/magnars/.emacs.d/blob/master/defuns/buffer-defuns.el#L144-166][Magnars' Emacs]]

#+BEGIN_SRC emacs-lisp
(defun indent-buffer ()
  (interactive)
  (indent-region (point-min) (point-max)))
#+END_SRC

*** Cleanup the buffer

Taken from [[https://github.com/magnars/.emacs.d/blob/master/defuns/buffer-defuns.el#L144-166][Magnars' Emacs]]

#+BEGIN_SRC emacs-lisp
(defun cleanup-buffer ()
  "Perform a bunch of operations on the whitespace content of a buffer.
Including indent-buffer, which should not be called automatically on save."
  (interactive)
  (untabify-buffer)
  (delete-trailing-whitespace)
  (indent-buffer))
#+END_SRC

*** Calculate expression and insert it

Useful for quick calculations, based on this reddit [[https://www.reddit.com/r/emacs/comments/445w6s/whats_some_small_thing_in_your_dotemacs_that_you/cznxx9f][post]].

#+BEGIN_SRC emacs-lisp
(defun my/calc-insert (arg)
  "Look for two numbers with a symbol between them and calculate their expression and replace them with the result"
  (interactive "p")
  (let (start end)
    (if (use-region-p)
        (setq start (region-beginning)
              end (region-end))
      (save-excursion
        (setq end (point))
        (setq start (search-backward-regexp "[0-9]+ ?[-+*/^] ?[0-9]+"
                                            (line-beginning-position) 1))))
    (let ((value (calc-eval (buffer-substring-no-properties start end))))
      (if (= arg 4)
          (message value)
        (delete-region start end)
        (insert value)))))

(bind-key "C-=" 'my/calc-insert)
#+END_SRC

*** Better =open-line=
I use =open-line= a lot and most of the time I have to manually indent the new line, lets fix this:

#+BEGIN_SRC emacs-lisp
(defun my/open-line (args)
  "Indent the new line after `open-line'"
  (interactive "p")
  (save-excursion
    (newline-and-indent))
  (indent-according-to-mode))

(bind-key "C-o" 'my/open-line)

#+END_SRC

*** Toggle quotes
Quickly toggle between =""= and =''=

#+BEGIN_SRC emacs-lisp
(use-package toggle-quotes
  :ensure t
  :commands toggle-quotes
  :bind (("C-'" . toggle-quotes)))
#+END_SRC

* Load my secrets

These are stuff I dont' want to commit to a public repo

#+BEGIN_SRC emacs-lisp
(load "~/.emacs.secrets" t)
#+END_SRC

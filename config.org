#+TITLE: My Emacs Configuration As an Org File

This is is inspired by [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha's]] Emacs configuration

* Configuration
** Personal Information

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Ammar Alammar"
      user-mail-address "ammar@ammasa.net")
#+END_SRC

** Emacs Initialization
*** Better Emacs Defaults

Emacs default configuration are awful, lets fix it.

If you want the meaning of these variables move the point to the desired variable
and press =C-h v=.

#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold (* 50 1024 1024)
      inhibit-startup-message t
      inhibit-startup-echo-area-message t
      echo-keystrokes 0.1
      ring-bell-function 'ignore
      scroll-conservatively 10
      hscroll-step 1
      mouse-wheel-scroll-amount '(0.01)
      mouse-wheel-progressive-speed nil
      font-lock-maximum-decoration t
      transient-mark-mode t
      delete-by-moving-to-trash t
      shift-select-mode nil
      comment-style 'multi-line
      uniquify-buffer-name-style 'forward
      truncate-partial-width-windows nil
      large-file-warning-threshold nil
      create-lockfiles nil)
#+END_SRC

*** Enable every disabled command

I just don't want to be prompted about disabled commands

#+BEGIN_SRC emacs-lisp
(setq disabled-command-function nil)
#+END_SRC

*** UTF-8 everywhere please

UTF-8 everything. Taken from [[http://stackoverflow.com/questions/2901541/which-coding-system-should-i-use-in-emacs][this answer]].

#+BEGIN_SRC emacs-lisp
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-language-environment 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(setq locale-coding-system 'utf-8)
#+END_SRC

*** Set LANG environment variable

#+BEGIN_SRC emacs-lisp
(setenv "LANG" "en_US.UTF-8")
#+END_SRC

*** Package sources

#+BEGIN_SRC emacs-lisp
(setq package--init-file-ensured t)

(package-initialize)

(setq package-archives
      '(("gnu" . "http://elpa.gnu.org/packages/")
        ("melpa" . "http://melpa.org/packages/")
        ("melpa-stable" . "http://stable.melpa.org/packages/")))

(unless package-archive-contents
  (package-refresh-contents))
#+END_SRC

*** Setup load path and use-package

I want to load packages outside of the package system, so I put them in
=~/.emacs.d/elisp=.

Read about [[https://github.com/jwiegley/use-package][use-package]].

Also install =auto-compile= mode so it byte-compile our init file

#+BEGIN_SRC emacs-lisp
(defvar my/elisp-dir (expand-file-name "elisp/" user-emacs-directory))
(defvar my/history-dir (expand-file-name "history/" user-emacs-directory))

(let ((default-directory my/elisp-dir))
  (normal-top-level-add-to-load-path '("."))
  (normal-top-level-add-subdirs-to-load-path))

(unless (package-installed-p 'use-package)
  (package-install 'use-package))

(setq use-package-verbose t
      use-package-always-ensure t)

(eval-when-compile
  (require 'use-package))

(setq load-prefer-newer t)

(use-package auto-compile
  :init
  (setq auto-compile-display-buffer nil
        auto-compile-mode-line-counter t)

  (auto-compile-on-load-mode))
#+END_SRC

*** Require Dash.el and S.el libraries

This configuration depends on [[https://github.com/magnars/dash.el][dash.el]] and [[https://github.com/magnars/s.el][s.el]] so load them early.

#+BEGIN_SRC emacs-lisp
(use-package s)
(use-package dash :init (dash-enable-font-lock))
#+END_SRC

*** Fix Emacs Interaction with OS X and $PATH

Some Emacs commands don't work properly on OS X, this fixes it.

#+BEGIN_SRC emacs-lisp
(defun on-osx-p ()
  (eq system-type 'darwin))

(use-package exec-path-from-shell
  :if (on-osx-p)
  :config
  :init
  (setq exec-path-from-shell-arguments nil)
  (setq exec-path-from-shell-variables '("PATH" "MANPATH" "LANG" "BROWSER" "DICPATH"))

  (exec-path-from-shell-initialize))
#+END_SRC

*** Use Bash as the default shell

I use Zsh as my default shell and Emacs doesn't like that.

#+BEGIN_SRC emacs-lisp
(setq shell-file-name "/bin/bash")
#+END_SRC

*** Use Bash as the default remote shell

#+BEGIN_SRC emacs-lisp
(setq explicit-shell-file-name "/bin/bash")
#+END_SRC

*** Use Org-mode for *scratch*

#+BEGIN_SRC emacs-lisp
(setq initial-major-mode 'org-mode)
#+END_SRC

** History And Session Configuration
*** Backups

I prefer to have all Emacs history files under one directory
(=~/emacs.d/history/=).

Emacs by default saves backup files in the current directory. Cluttering your
directory with files ending with =~=, this stashes them away in
=~/emacs.d/history/backups/=

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist (list (cons "."  (concat my/history-dir "backups"))))
#+END_SRC

And save lots.

#+BEGIN_SRC emacs-lisp
(setq delete-old-versions -1)
(setq version-control t)
(setq vc-make-backup-files t)
(setq auto-save-file-name-transforms (list (list ".*" (concat my/history-dir "auto-save-list/") t)))
(setq auto-save-list-file-prefix (concat my/history-dir "auto-save-list/saves-"))
#+END_SRC

*** Session history

This saves our position in files other things between Emacs sessions.

#+BEGIN_SRC emacs-lisp
(setq history-length t
      history-delete-duplicates t
      savehist-save-minibuffer-history 1
      savehist-file (concat my/history-dir "savehist")
      savehist-additional-variables '(kill-ring
                                      search-ring
                                      regex-search-ring
                                      extended-command-history)
      save-place-file (concat my/history-dir "saveplace"))

(savehist-mode)
#+END_SRC

*** Recentf

Remembers visited files.

#+BEGIN_SRC emacs-lisp
(setq recentf-auto-cleanup 'never
      recentf-max-saved-items 100
      recentf-save-file (concat my/history-dir "recentf"))

(recentf-mode)
#+END_SRC

*** Bookmarks File

#+BEGIN_SRC emacs-lisp
(setq bookmark-default-file (concat my/history-dir "bookmarks"))
#+END_SRC

*** Misc history files

These files show up in my =.emacs.d=, so lets stick them in the history file

#+BEGIN_SRC emacs-lisp
(setq image-dired-dir (concat my/history-dir "image-dired/"))
#+END_SRC

** Emacs General Configuration
*** Load customization

#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "customization.el" user-emacs-directory))
(load custom-file)
#+END_SRC

*** Start Emacs server

#+BEGIN_SRC emacs-lisp
(if window-system (add-hook 'after-init-hook 'server-start t))
#+END_SRC

*** Don't ask when I kill a buffer that has a process running

#+BEGIN_SRC emacs-lisp
(setq kill-buffer-query-functions
      (remq 'process-kill-buffer-query-function
            kill-buffer-query-functions))
#+END_SRC

*** Allows Emacs to open compressed files and compresses them back when you save the file.

#+BEGIN_SRC emacs-lisp
(auto-compression-mode)
#+END_SRC

*** Set the cursor to be a line

#+BEGIN_SRC emacs-lisp
(setq-default cursor-type 'bar)
#+END_SRC

*** Highlight matching parentheses when the cursor is on them.

#+BEGIN_SRC emacs-lisp
(show-paren-mode)
#+END_SRC

*** Don't use tabs for indentation.

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

*** Set tab width

#+BEGIN_SRC emacs-lisp
(setq-default tab-width 2)
#+END_SRC

*** Highlight the current line

#+BEGIN_SRC emacs-lisp
(global-hl-line-mode)
#+END_SRC

*** Add newline at the end of the file

#+BEGIN_SRC emacs-lisp
(setq-default require-final-newline t)
#+END_SRC

*** Disable =magic-mode=

#+BEGIN_SRC emacs-lisp
(setq magic-mode-alist nil)
#+END_SRC

*** Show column number

#+BEGIN_SRC emacs-lisp
(column-number-mode)
#+END_SRC

*** Enable subword mode

#+BEGIN_SRC emacs-lisp
(global-subword-mode)
#+END_SRC

*** Sentence end

Sentence end with only one space.

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

*** Change "yes or no" to "y or n"

I'm lazy okay?

#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Use system trash instead of using =rm=

I =trash= command installed from homebrew, this makes files deleted from Emacs go
to the Trash folder.

#+BEGIN_SRC emacs-lisp
(defun my/system-move-file-to-trash (file)
  "Use \"trash\" to move FILE to the system trash"
  (call-process (executable-find "trash") nil 0 nil file))

(if (on-osx-p)
    (defalias 'move-file-to-trash 'my/system-move-file-to-trash))
#+END_SRC

*** Set the default browser

#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'browse-url-chromium
      browse-url-chromium-program "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome")
#+END_SRC

*** Tramp

#+BEGIN_SRC emacs-lisp
(setq tramp-persistency-file-name (concat my/history-dir "tramp")
      tramp-default-method "ssh"
      vc-ignore-dir-regexp (format "\\(%s\\)\\|\\(%s\\)"
                                   vc-ignore-dir-regexp
                                   tramp-file-name-regexp))
#+END_SRC

*** Calc

It's so much easier to hit =8= than =*=.

#+BEGIN_SRC emacs-lisp
(bind-keys ("C-x 8 q" . quick-calc))
#+END_SRC

*** Switch back to Terminal.app after emacsclient

When I call emacsclient I'm definitely on Terminal.app

#+BEGIN_SRC emacs-lisp
(defun my/focus-terminal ()
  ;; Don't switch if we are committing to git
  (unless (or (get-buffer "COMMIT_EDITMSG")
              (get-buffer "git-rebase-todo"))
    (do-applescript "tell application \"Terminal\" to activate")))

(if (on-osx-p)
    (add-hook 'server-done-hook #'my/focus-terminal))
#+END_SRC

*** Emacs Client

I want =C-c C-c= to end the editing session.

#+BEGIN_SRC emacs-lisp
(add-hook 'server-visit-hook
          (lambda ()
            (local-set-key (kbd "C-c C-c") 'server-edit)))
#+END_SRC

*** Override Emacs keybinding
**** Unbinding

Unbinding these keys because they are used for something else

#+BEGIN_SRC emacs-lisp
(unbind-key "C-;")
(unbind-key "C-x m")
#+END_SRC

**** Bindings

These are my personal preference to the default Emacs keybindings.

#+BEGIN_SRC emacs-lisp
(bind-keys ("C-s" . isearch-forward-regexp)
           ("C-r" . isearch-backward-regexp)
           ("C-M-s" . isearch-forward)
           ("C-M-r" . isearch-backward)
           ("C-h a" . apropos)
           ("C-w" . backward-kill-word)
           ("C-x C-k" . kill-region)
           ("M-/" . hippie-expand)
           ("RET" . reindent-then-newline-and-indent)
           ("C-x t l" . toggle-truncate-lines)
           ("C-<tab>" . indent-for-tab-command)
           ("C-x s" . save-buffer))
#+END_SRC

**** Window movement

Use =Shift-Arrows= to move between windows

#+BEGIN_SRC emacs-lisp
(windmove-default-keybindings)

(defun my/switch-window-forward ()
  (interactive)
  (other-window 1))

(defun my/switch-window-backward ()
  (interactive)
  (other-window -1))

(bind-keys ("C-x o" . my/switch-window-backward)
           ("C-x C-o" . my/switch-window-forward))
#+END_SRC

**** Quickly switch to previous buffer

#+BEGIN_SRC emacs-lisp
(defun my/previous-buffer ()
  (interactive)
  (switch-to-buffer (other-buffer (current-buffer) 1)))

(bind-key "M-`" 'my/previous-buffer)
#+END_SRC

**** Window splitting

Copied from [[http://www.reddit.com/r/emacs/comments/25v0eo/you_emacs_tips_and_tricks/chldury][reddit comment]]

#+BEGIN_SRC emacs-lisp
(defun my/vertical-split-buffer (prefix)
  "Split the window vertically and display the previous buffer."
  (interactive "p")
  (split-window-vertically)
  (other-window 1 nil)
  (if (= prefix 1) (switch-to-next-buffer)))

(defun my/horizontal-split-buffer (prefix)
  "Split the window horizontally and display the previous buffer."
  (interactive "p")
  (split-window-horizontally)
  (other-window 1 nil)
  (if (= prefix 1) (switch-to-next-buffer)))

(bind-keys ("C-x 2" . my/vertical-split-buffer)
           ("C-x 3" . my/horizontal-split-buffer))
#+END_SRC

**** Eshell

#+BEGIN_SRC emacs-lisp
(use-package eshell
  :commands eshell
  :config
  (setq eshell-history-file-name (concat my/history-dir "eshell/history")
        eshell-glob-case-insensitive t
        eshell-cmpl-ignore-case t))
#+END_SRC

** Appearance Configuration
*** Window configuration

I rarely, if ever, use the mouse in Emacs. This disable the GUI elements

#+BEGIN_SRC emacs-lisp
(when window-system
  (tooltip-mode -1)
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1))
#+END_SRC

Don't ever use GUI dialog boxes

#+BEGIN_SRC emacs-lisp
(setq use-dialog-box nil)
#+END_SRC

Resize Emacs window (called frame in Emacs jargon) as pixels instead of chars resulting in fully sized window.

#+BEGIN_SRC emacs-lisp
(setq frame-resize-pixelwise t)
#+END_SRC

Remember cursor position when scrolling

#+BEGIN_SRC emacs-lisp
(setq scroll-preserve-screen-position 'always)
#+END_SRC

Add a bigger offset to underline property (it makes smart-mode-line looks way nicer)

#+BEGIN_SRC emacs-lisp
(setq underline-minimum-offset 4)
#+END_SRC

*** Fonts and colors
**** Default font

First, themes and other modes can overwrrite our =set-face-attributes=. Lets write a helper

#+BEGIN_SRC emacs-lisp
(defmacro after-init (&rest args)
  `(add-hook 'after-init-hook
             (lambda () ,@args)))
#+END_SRC

Set the default font

#+BEGIN_SRC emacs-lisp
(after-init
 (set-face-attribute 'default nil
                     :height 120
                     :family "Menlo"
                     :foreground "#819090"))
#+END_SRC

**** Font lock faces

#+BEGIN_SRC emacs-lisp
(after-init
 (set-face-attribute 'font-lock-builtin-face nil
                     :foreground "#6193B3")

 (set-face-attribute 'font-lock-comment-face nil
                     :foreground "#53686f")

 (set-face-attribute 'font-lock-constant-face nil
                     :foreground "DeepSkyBlue3")

 (set-face-attribute 'font-lock-function-name-face nil
                     :weight 'bold))
#+END_SRC

**** Highlight color

#+BEGIN_SRC emacs-lisp
(after-init
 (set-face-attribute 'highlight nil
                     :background "#1c4c5e"))
#+END_SRC

**** Region color

#+BEGIN_SRC emacs-lisp
(after-init
 (set-face-attribute 'region nil
                     :background "#175062"))

#+END_SRC

**** Minibuffer

#+BEGIN_SRC emacs-lisp
(after-init
 (set-face-attribute 'minibuffer-prompt nil
                     :foreground "#2076c8"))

#+END_SRC

**** Parentheses match

#+BEGIN_SRC emacs-lisp
(after-init
 (set-face-attribute 'show-paren-match nil
                     :foreground "#c71b6f"
                     :background "#0a2832"))

#+END_SRC

*** Smart Mode Line

Compact mode line

#+BEGIN_SRC emacs-lisp
(use-package smart-mode-line
  :init
  (setq sml/no-confirm-load-theme t
        sml/shorten-directory t
        sml/show-file-name t
        sml/theme 'respectful
        rm-whitelist " FlyC*"
        rm-blacklist " Fly\\'")

  (sml/setup)

  (--each '(("^~/Code/" ":Code:")
            ("^~/Code/gh/" ":Github:")
            ("^~/Code/forks/" ":forks:"))
    (push it sml/replacer-regexp-list)))
#+END_SRC

*** Set up Solarized color theme

Solarized is so good.

#+BEGIN_SRC emacs-lisp
(use-package solarized-theme
  :init
  (setq solarized-scale-org-headlines nil)

  (load-theme 'solarized-dark))
#+END_SRC

*** Rainbow Delimiters

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :config
  (setq rainbow-delimiters-max-face-count 1)

  (--each '(prog-mode-hook
            emacs-lisp-mode-hook
            org-mode-hook
            markdown-mode-hook)
    (add-hook it #'rainbow-delimiters-mode))

  (set-face-attribute 'rainbow-delimiters-depth-1-face nil :foreground "#A52E66")
  (set-face-attribute 'rainbow-delimiters-depth-3-face nil :foreground "#384311")
  (set-face-attribute 'rainbow-delimiters-depth-4-face nil :foreground "#384311")
  (set-face-attribute 'rainbow-delimiters-depth-5-face nil :foreground "#384311")
  (set-face-attribute 'rainbow-delimiters-depth-6-face nil :foreground "#384311")
  (set-face-attribute 'rainbow-delimiters-depth-7-face nil :foreground "#384311")
  (set-face-attribute 'rainbow-delimiters-depth-8-face nil :foreground "#384311")
  (set-face-attribute 'rainbow-delimiters-depth-9-face nil :inherit 'rainbow-delimiters-depth-1-face)

  (set-face-attribute 'rainbow-delimiters-unmatched-face nil :foreground "#d11a24"))
#+END_SRC

*** Highlight the current line

#+BEGIN_SRC emacs-lisp
(global-hl-line-mode)
#+END_SRC

*** Prettify symbols

Automatically transform symbols like lambda into the greek letter =λ=

#+BEGIN_SRC emacs-lisp
(--each '(org-mode-hook
          ruby-mode-hook)
  (add-hook it
            (lambda () (add-to-list 'prettify-symbols-alist '("lambda" . ?λ)))))

(--each '(js-mode-hook
          js2-mode-hook
          rjsx-mode-hook)
  (add-hook it
            (lambda () (setq-local prettify-symbols-alist nil))))

(global-prettify-symbols-mode)
#+END_SRC

*** Set Fringe Mode to 1 pixels and remove newline indicators

#+BEGIN_SRC emacs-lisp
(set-fringe-mode 1)
#+END_SRC


** Mode Configuration
*** Pin Depencies to stable versions

#+BEGIN_SRC emacs-lisp
(-each '((diminish . "melpa-stable")
         (epl . "melpa-stable")
         (f . "melpa-stable")
         (git-commit . "melpa-stable")
         (hydra . "melpa-stable")
         (inflections . "melpa-stable")
         (logito . "melpa-stable")
         (makey . "melpa-stable")
         (names . "melpa-stable")
         (packed . "melpa-stable")
         (pcache . "melpa-stable")
         (pkg-info . "melpa-stable")
         (popup . "melpa-stable")
         (rich-minority . "melpa-stable")
         (s . "melpa-stable")
         (use-package . "melpa-stable")
         (with-editor . "melpa-stable"))
  (lambda (package)
    (add-to-list 'package-pinned-packages package)))

#+END_SRC

*** Ivy - Interactive Completion

Ivy is a lightweight completion system

#+BEGIN_SRC emacs-lisp
(use-package ivy
  :bind (("C-s" . swiper)
         ("C-x C-b" . ivy-switch-buffer)
         ("C-x c b" . ivy-resume)
         :map ivy-minibuffer-map
         ("<return>" . ivy-alt-done))
  :config
  (setq ivy-use-virtual-buffers t
        ivy-height 15
        ivy-extra-directories nil
        ivy-initial-inputs-alist nil
        ivy-re-builders-alist '((t . ivy--regex-ignore-order)))

  (set-face-attribute 'ivy-current-match nil
                      :background "#0D4553")
  (set-face-attribute 'ivy-highlight-face nil
                      :background "#0A3641"
                      :foreground "#A2B1B1")

  (ivy-mode))
#+END_SRC

Counsel adds a lot of extra functionality & integraion to ivy-mode

#+BEGIN_SRC emacs-lisp
(use-package counsel
  :bind (("C-x C-m" . counsel-M-x)
         ("C-x m" . counsel-M-x)
         ("C-c s" . counsel-ag)
         ("M-y" . counsel-yank-pop)
         ("C-x C-f" . counsel-find-file)
         ("C-x C-i" . counsel-imenu)
         ("C-x c p" . counsel-list-processes)
         ("M-?" . counsel-company)
         ("C-h f" . counsel-describe-function)
         ("C-h v" . counsel-describe-variable)
         ("C-h l" . counsel-find-library)
         ("C-h i" . counsel-info-lookup-symbol)
         ("C-h u" . counsel-unicode-char)
         :map counsel-find-file-map
         ("C-l" . ivy-backward-delete-char))
  :config
  (setq counsel-yank-pop-separator "\n\n"
        counsel-find-file-ignore-regexp "\\`\\.")

  (defalias 'cpkg 'counsel-package)

  ;; Add copy, move, and delete commands to counsel-find-file
  (defun given-file (command prompt)
    "Run `command' with `prompt', `source', and `target'. `source' is set from `ivy' and `target' is set from prompting the user"
    (apply-partially
     '(lambda (command prompt source)
        (let ((target (read-file-name (format "%s %s to:" prompt source))))
          (funcall command source target 1)))
     command prompt))


  (ivy-add-actions
   'counsel-find-file
   `(("c" ,(given-file #'copy-file "Copy") "cp")
     ("d" move-file-to-trash "rm")
     ("m" ,(given-file #'rename-file "Move") "mv"))))
#+END_SRC

*** Projectile

Projectile mode is one the best packages Emacs have, more information is in this
[[http://tuhdo.github.io/helm-projectile.html][blog]] post.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :bind ("C-c C-p" . projectile-command-map)
  :init
  (projectile-global-mode)

  (setq projectile-enable-caching t
        projectile-cache-file (concat my/history-dir "projectile.cache")
        projectile-completion-system 'ivy
        projectile-file-exists-remote-cache-expire nil
        projectile-known-projects-file (concat my/history-dir "projectile-bookmarks.eld"))

  (setq projectile-ignored-project-function
        (lambda (project)
          (--any? (s-starts-with? (expand-file-name it) project)
                  '("~/.zprezto/modules/"
                    "/usr/loca/"
                    "~/.rbenv/"))))

  (push "node_modules" projectile-globally-ignored-directories)

  (projectile-load-known-projects))
#+END_SRC

Add even more integration between Projectile and Ivy

#+BEGIN_SRC emacs-lisp
(use-package counsel-projectile
  :bind (:map counsel-projectile-map
              ("C-SPC" . counsel-projectile-drop-to-switch-project))
  :init (counsel-projectile-on))
#+END_SRC

*** Projectile Rails

Extension to Projectile for navigating Rails files.

#+BEGIN_SRC emacs-lisp
(use-package projectile-rails
  :config
  (setq projectile-rails-font-lock-face-name 'font-lock-builtin-face
        projectile-rails-stylesheet-re "\\.scss\\'")

  (set-face-attribute 'projectile-rails-keyword-face nil
                      :inherit 'font-lock-builtin-face)

  (--each '(ruby-mode-hook
            web-mode-hook
            yaml-mode-hook
            scss-mode-hook
            js2-mode-hook)
    (add-hook it (lambda () (when (projectile-project-p) (projectile-rails-on))))))
#+END_SRC

*** Smartparens mode

This package manages pairs for you, so if you insert =(= it automatically inserts
the closing pair.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :pin melpa-stable
  :bind (:map sp-keymap
              ("M-<backspace>" . sp-unwrap-sexp)
              ("M-." . sp-forward-slurp-sexp)
              ("M-," . sp-forward-barf-sexp)
              ("C-M-." . sp-backward-slurp-sexp)
              ("C-M-," . sp-backward-barf-sexp))
  :init
  (smartparens-global-mode)
  :config
  (setq sp-base-key-bindings 'sp
        sp-highlight-pair-overlay nil
        sp-highlight-wrap-overlay nil
        sp-highlight-wrap-tag-overlay nil)

  (use-package smartparens-config :ensure nil)
  (sp-use-smartparens-bindings)

  (sp-pair "(" nil :post-handlers '(("| " "SPC")))
  (sp-pair "[" nil :post-handlers '(("| " "SPC")))
  (sp-pair "{" nil :post-handlers '(("| " "SPC")))

  (add-hook 'nxml-mode-hook
            (lambda ()
              (sp-local-pair 'nxml-mode "<" ">" :actions :rem)))

  (add-hook 'web-mode-hook
            (lambda ()
              (sp-local-pair 'web-mode "<" nil :actions :rem)
              (sp-local-pair 'web-mode "<%" "%>" :post-handlers '(("| " "SPC") (" | " "=")))))

  ;; Do not escape closing pair in string interpolation
  (add-hook 'swift-mode-hook
            (lambda ()
              (sp-local-pair 'swift-mode "\\(" nil :actions :rem)
              (sp-local-pair 'swift-mode "\\(" ")")))

  (set-face-attribute 'sp-show-pair-match-face nil
                      :foreground "#d73182")
  (set-face-attribute 'sp-show-pair-mismatch-face nil
                      :background "#810160")

  (show-smartparens-global-mode))
#+END_SRC

Change beginning/end of s-expression movement to go outside of the s-expression when the =point= is at the beginning/end of the s-expression.

#+BEGIN_SRC emacs-lisp
(defun my/sp-beginning-of-sexp ()
  "Move to the beginning of sexp, if at beginning then move before it"
  (interactive)
  (let* ((sexp (or (sp-get-enclosing-sexp) (sp-get-sexp)))
         (beginning (sp-get sexp :beg-in)))
    (if (= beginning (point))
        (goto-char (1- beginning))
      (sp-beginning-of-sexp))))

(defun my/sp-end-of-sexp ()
  "Move to the end of sexp, if at end then move after it"
  (interactive)
  (let* ((sexp (or (sp-get-enclosing-sexp) (sp-get-sexp)))
         (end (sp-get sexp :end-in)))
    (if (= end (point))
        (goto-char (1+ end))
      (sp-end-of-sexp))))

(bind-keys :map sp-keymap
           ("C-M-a" . my/sp-beginning-of-sexp)
           ("C-M-e" . my/sp-end-of-sexp))
#+END_SRC

*** Magit

Better interface to Git

#+BEGIN_SRC emacs-lisp
(use-package magit
  :pin melpa-stable
  :commands magit-status
  :bind ("C-c <return>" . magit-status)
  :config
  (setq magit-push-always-verify nil
        magit-revert-buffers 'silent
        magit-diff-refine-hunk 't
        magit-completing-read-function 'ivy-completing-read
        magit-display-buffer-function #'magit-display-buffer-fullcolumn-most-v1)

  (set-face-attribute 'magit-blame-date nil
                      :foreground "#D13A82"
                      :background "#2D393D")
  (set-face-attribute 'magit-blame-hash nil
                      :foreground "#C4A449"
                      :background "#2D393D")
  (set-face-attribute 'magit-blame-heading nil
                      :foreground "#D13A82"
                      :background "#2D393D")
  (set-face-attribute 'magit-blame-summary nil
                      :foreground "#2D8CD0"
                      :background "#2D393D")
  (set-face-attribute 'magit-blame-name nil
                      :foreground "#C4A449"
                      :background "#2D393D")
  (set-face-attribute 'magit-diff-context-highlight nil
                      :background "#0b3b46")
  (set-face-attribute 'smerge-refined-added nil
                      :inherit 'magit-diff-added-highlight)
  (set-face-attribute 'smerge-refined-removed nil
                      :inherit 'magit-diff-removed)

  (use-package magit-popup :pin melpa-stable)

  (use-package git-commit
    :config
    (setq git-commit-setup-hook
          (-replace 'git-commit-turn-on-auto-fill
                    'git-commit-turn-on-flyspell
                    git-commit-setup-hook))))
#+END_SRC

Set the visibility of the =Unmerged into upstream= section to always be hidden, see [[http://emacs.stackexchange.com/questions/20754/change-the-default-visibility-of-a-magit-section/20767][this stackexchange question]].


#+BEGIN_SRC emacs-lisp
(defun my/magit-initially-hide-unmerged (section)
  (and (not magit-insert-section--oldroot)
       (eq (magit-section-type section) 'unpushed)
       (equal (magit-section-value section) "@{upstream}..")
       'hide))

(add-hook 'magit-section-set-visibility-hook #'my/magit-initially-hide-unmerged)
#+END_SRC

*** Git Time Machine

Time machine like interface for git

#+BEGIN_SRC emacs-lisp
(use-package git-timemachine
  :commands git-timemachien)
#+END_SRC

*** Company Mode

#+BEGIN_SRC emacs-lisp
(use-package company
  :pin melpa-stable
  :init
  (setq company-global-modes '(not inf-ruby-mode eshell-mode)
        company-idle-delay 0.3
        company-minimum-prefix-length 3
        company-dabbrev-downcase nil)

  (global-company-mode))
#+END_SRC

When Company suggestions is shown pressing =C-w= will be captured by Company and will not execute =backward-kill-word=.

#+BEGIN_SRC emacs-lisp
(defun my/company-abort ()
  "Make company mode not steal C-w and instead pass it down"
  (interactive)
  (company-abort)
  (execute-kbd-macro (kbd "C-w")))

(bind-keys :map company-active-map
          ("C-w" . my/company-abort))
#+END_SRC

Add Flow integration with company-mode

#+BEGIN_SRC emacs-lisp
(use-package company-flow
  :functions company-flow
  :config
  (--each '(js2-mode-hook
            rjsx-mode-hook)
    (add-hook it
              (lambda () (add-to-list 'company-backends 'company-flow)))))
#+END_SRC

*** Flycheck

Flycheck is a modern lint runner.

#+BEGIN_SRC emacs-lisp
(defun my/current-buffer-is-a (extension)
  "Return true if current buffer name ends with `extension'"
  (let ((file (buffer-file-name (current-buffer))))
    (s-ends-with? extension file)))

(use-package flycheck
  :pin melpa-stable
  :bind (("C-c ! ," . flycheck-list-errors))
  :init
  (setq flycheck-indication-mode 'right-fringe)

  (add-hook 'js2-mode-hook
            (lambda () (setq-local flycheck-checker 'javascript-eslint)))

  (add-hook 'emacs-lisp-mode-hook
            (lambda () (add-to-list 'flycheck-disabled-checkers 'emacs-lisp-checkdoc)))

  (global-flycheck-mode))
#+END_SRC

Add Flow integration with flycheck

#+BEGIN_SRC emacs-lisp
(use-package flycheck-flow
  :config
  (add-hook 'js2-mode-hook
            (lambda ()
              (let ((file (buffer-file-name (current-buffer))))
                (when (--any? (s-ends-with? it file)
                              '(".js" ".jsx")))
                (flycheck-add-next-checker 'javascript-eslint 'javascript-flow)))))
#+END_SRC

*** Winner

Winner mode gives you the ability to undo and redo your window configuration, watch
this [[https://www.youtube.com/watch?v%3DT_voB16QxW0][video]] for better explanation.

#+BEGIN_SRC emacs-lisp
(use-package winner
  :init (winner-mode))
#+END_SRC

*** Discover Major Mode keybindings

#+BEGIN_SRC emacs-lisp
(use-package discover-my-major
  :commands discover-my-major
  :bind ("C-h C-m" . discover-my-major))
#+END_SRC

*** Multiple Cursors

As the name suggest, it allows editing over multiple lines

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :bind (("C-c SPC" . mc/edit-lines)
         ("M-]" . mc/mark-next-like-this)
         ("M-[" . mc/mark-previous-like-this)
         ("M-}" . mc/unmark-next-like-this)
         ("M-{" . mc/unmark-previous-like-this))
  :config
  (setq mc/list-file (concat my/history-dir "mc-lists.el")))
#+END_SRC

*** Abbrev mode

Useful for defining abbreviations

#+BEGIN_SRC emacs-lisp
(setq save-abbrevs t
      abbrev-file-name (concat my/history-dir "abbrev_defs"))
(setq-default abbrev-mode t)
#+END_SRC

*** Paradox

A better alternative to =package-list-packages=

#+BEGIN_SRC emacs-lisp
(use-package paradox
  :commands pkg
  :config
  (setq paradox-automatically-star t
        paradox-execute-asynchronously t
        paradox-lines-per-entry 1
        paradox-github-token t)

  (defalias 'pkg 'paradox-list-packages))
#+END_SRC

*** Ispell

Use hunspell because it's more powerful and supports Arabic.

#+BEGIN_SRC emacs-lisp
(setq ispell-program-name "hunspell"
      ispell-dictionary "en_US"
      ispell-really-hunspell t
      ispell-keep-choices-win t
      ispell-use-framepop-p nil)

(add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_SRC" . "#\\+END_SRC"))
#+END_SRC

Use both Ispell and abbrev together. ([[http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html][source]])

#+BEGIN_SRC emacs-lisp
(defun ispell-word-then-abbrev (p)
  "Call `ispell-word'. Then create an abbrev for the correction made.
With prefix P, create local abbrev. Otherwise it will be global."
  (interactive "P")
  (let ((bef (downcase (or (thing-at-point 'word) ""))) aft)
        (call-interactively 'ispell-word)
        (setq aft (downcase (or (thing-at-point 'word) "")))
        (unless (string= aft bef)
          (message "\"%s\" now expands to \"%s\" %sally"
                   bef aft (if p "loc" "glob"))
          (define-abbrev
        (if p local-abbrev-table global-abbrev-table)
        bef aft))))

(bind-keys ("C-x t i" . ispell-word-then-abbrev))
#+END_SRC

*** Flyspell

Unbind those keys from flyspell-mode

#+BEGIN_SRC emacs-lisp
(add-hook 'flyspell-mode-hook
          (lambda ()
            (unbind-key "C-." flyspell-mode-map)
            (unbind-key "C-;" flyspell-mode-map)))
#+END_SRC

*** Undo Tree

A better undo/redo alternative

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :bind ("C-M-_" . undo-tree-visualize)
  :init
  (global-undo-tree-mode))
#+END_SRC

*** Avy

Similar to ace-jump above

#+BEGIN_SRC emacs-lisp
(use-package avy
  :commands avy-goto-char-timer
  :bind ("C-." . avy-goto-char-timer)
  :config
  (setq avy-style 'at)

  (avy-setup-default))
#+END_SRC

*** Popwin

Popwin makes popup window awesome again, every popup window can be closed by =C-g=.

#+BEGIN_SRC emacs-lisp
(use-package popwin
  :bind ("C-h e" . popwin:messages)
  :bind-keymap ("C-z" . popwin:keymap)
  :init
  (autoload 'popwin-mode "popwin.el" nil t)
  (popwin-mode)
  :config
  (--each '(("*rspec-compilation*" :tail nil)
            "*Apropos*"
            "*Warnings*"
            "*projectile-rails-server*"
            "*coffee-compiled*"
            "*Bundler*"
            "*projectile-rails-compilation*"
            "*Ack-and-a-half*"
            ("*ruby*" :height 0.75)
            ("*rails*" :height 0.75)
            "*Compile-Log*"
            "*pry*"
            "*SQL*"
            "*projectile-rails-generate*"
            "*Package Commit List*"
            "*Compile-Log*"
            (" *undo-tree*" :position bottom)
            "*compilation*"
            ("RuboCop.*" :regexp 't)
            "*elm*"
            "*xcrun swift*"
            ("*HTTP Response*" :position bottom :height 30)
            "*Flycheck errors*"
            ("*Flycheck error messages*" :noselect t)
            ("\*ivy-occur.*" :regexp 't))
    (push it popwin:special-display-config)))
#+END_SRC

*** Aggressive Indent Mode

#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :commands aggressive-indent-mode
  :config
  (add-to-list 'aggressive-indent-dont-indent-if
               '(and (derived-mode-p 'sgml-mode)
                     (string-match "^[[:space:]]*{%"
                                   (thing-at-point 'line)))))
#+END_SRC

*** Ediff Mode

#+BEGIN_SRC emacs-lisp
(add-hook 'ediff-mode-hook
          (lambda ()
(setq ediff-merge-split-window-function 'split-window-vertically
      ediff-split-window-function  'split-window-horizontally
      ediff-window-setup-function 'ediff-setup-windows-plain)

(set-face-attribute 'ediff-current-diff-C nil :background "#41421c")
(set-face-attribute 'ediff-fine-diff-A nil :background "#630813")
(set-face-attribute 'ediff-fine-diff-B nil :background "#0a4c1b")            ))
#+END_SRC

*** A better query regexp replace

#+BEGIN_SRC emacs-lisp
(use-package visual-regexp
  :commands qrr
  :config
  (defalias 'qrr 'vr/query-replace))
#+END_SRC

*** Auto revert mode

Whenever a file opened by Emacs changed by an external program, this mode
automatically reload the file

#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode)
#+END_SRC

*** Whitespace mode

Automatically cleans buffers of useless whitespaces and highlights trailing
whitespaces.

#+BEGIN_SRC emacs-lisp
(global-whitespace-mode)

(setq whitespace-action '(auto-cleanup)
      whitespace-style '(trailing
                         lines
                         empty
                         space-before-tab
                         indentation
                         space-after-tab))

(set-face-attribute 'whitespace-trailing nil
                    :background "#20546d"
                    :foreground "#c60007")
#+END_SRC

*** Iedit mode

Iedit lets you mark all occurrences of a word to edit them at the same time.

#+BEGIN_SRC emacs-lisp
(use-package iedit
  :commands iedit-mode
  :bind ("C-;" . iedit-mode))
#+END_SRC

*** Expand region

Expand region to fit the sexp

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :commands er/expand-region
  :bind ("M-2" . er/expand-region))
#+END_SRC

*** Persistent *sractch*

#+BEGIN_SRC emacs-lisp
(use-package persistent-scratch
  :config
  (setq persistent-scratch-save-file (concat my/history-dir "persistent-scratch"))

  (persistent-scratch-setup-default))
#+END_SRC

*** Clone Github projects from Emacs

#+BEGIN_SRC emacs-lisp
(use-package github-clone
  :commands github-clone)
#+END_SRC

*** Feature Mode

#+BEGIN_SRC emacs-lisp
(use-package feature-mode
  :mode "\\.feature\\'")
#+END_SRC

*** Dired Mode

#+BEGIN_SRC emacs-lisp
(use-package dired
  :ensure nil
  :bind (:map dired-mode-map
              ("C-l" . dired-up-directory))
  :config
  (setq dired-listing-switches "-alh"))
#+END_SRC

*** Shell Conf Mode

#+BEGIN_SRC emacs-lisp
(use-package sh-mode
  :ensure nil
  :mode ("\\.zsh\\'" "\\.gitignore\\'" "\\.envrc\\'")
  :interpreter "zsh"
  :init
  (setq-default sh-indentation 2
                sh-basic-offset 2))
#+END_SRC

I use [[https://github.com/sorin-ionescu/prezto][prezto]] and I want to associate zsh files without extension to =sh-mode=

#+BEGIN_SRC emacs-lisp
(add-to-list 'magic-fallback-mode-alist
             '((lambda () (s-match ".*prezto.*" (buffer-file-name))) . sh-mode))
#+END_SRC

*** Restclient

#+BEGIN_SRC emacs-lisp
(use-package restclient
  :commands restclient-mode)
#+END_SRC

** Writing And Programming Modes

Set the global `fill-column`

#+BEGIN_SRC emacs-lisp
(setq-default fill-column 88)
#+END_SRC

*** Variable pitch mode

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'variable-pitch nil
                    :font "Sahl Naskh"
                    :height 160
                    :width 'normal
                    :weight 'normal)

(bind-keys ("C-x t v" . variable-pitch-mode))
#+END_SRC

*** Text mode

#+BEGIN_SRC emacs-lisp
(use-package text-mode
  :preface (provide 'text-mode)
  :ensure nil
  :mode ("\\.txt" "\\.text\\'")
  :config
  (add-hook 'text-mode-hook
            (lambda ()
              (turn-on-auto-fill)
              (turn-on-flyspell)
              (setq-local word-wrap t))))
#+END_SRC

*** Markdown mode

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :mode ("\\.md\\'" "\\.markdown\\'")
  :config
  (set-face-attribute 'markdown-bold-face nil
                      :weight 'bold
                      :inherit 'font-lock-builtin-face))
#+END_SRC

*** Org Mode

General org-mode configuration

#+BEGIN_SRC emacs-lisp
(use-package org
  :mode ("\\.org\\'" . org-mode)
  :config
  (setq org-log-done t
        org-adapt-indentation nil
        org-fontify-whole-heading-line t
        org-pretty-entities t
        org-goto-interface 'outline
        org-goto-max-level 10
        org-imenu-depth 5
        org-src-fontify-natively t
        org-src-tab-acts-natively nil
        org-src-window-setup 'current-window
        org-src-strip-leading-and-trailing-blank-lines t
        org-edit-src-content-indentation 0
        org-startup-folded nil)

  (add-hook 'org-mode-hook
            (lambda ()
              (variable-pitch-mode nil)
              (toggle-truncate-lines)))

  (set-face-attribute 'org-level-1 nil :font "Menlo" :weight 'bold)
  (set-face-attribute 'org-level-2 nil :inherit 'org-level-1)
  (set-face-attribute 'org-level-3 nil :inherit 'org-level-1)
  (set-face-attribute 'org-level-4 nil :inherit 'org-level-1)
  (set-face-attribute 'org-level-5 nil :inherit 'org-level-1)
  (set-face-attribute 'org-level-6 nil :inherit 'org-level-1)
  (set-face-attribute 'org-todo nil
                      :background "#052028"
                      :foreground "#c60007"))
#+END_SRC

When I'm editing org documents, sometimes I like to narrow to an org-mode section and use Next Section and Previous Section to move between the sections. (taken from this [[https://www.reddit.com/r/emacs/comments/60nb8b/favorite_builtin_emacs_commands/df8b7vm/][reddit comment]])

#+BEGIN_SRC emacs-lisp
(defun my/org-next ()
  (interactive)
  (when (buffer-narrowed-p)
    (beginning-of-buffer)
    (widen)
    (org-forward-heading-same-level 1))
  (org-narrow-to-subtree))

(defun my/org-previous ()
  (interactive)
  (when (buffer-narrowed-p)
    (beginning-of-buffer)
    (widen)
    (org-backward-heading-same-level 1))
  (org-narrow-to-subtree))

(bind-keys :map org-mode-map
           ("C-x t n" . my/org-next)
           ("C-x t p" . my/org-previous))
#+END_SRC

*** Emacs Lisp Mode

#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook
          (lambda ()
            (aggressive-indent-mode)
            (turn-on-eldoc-mode)))
#+END_SRC

Sometimes I use elisp as a calculator, this evaluates the current s-expression and
if =universal-argument= is supplied it replaces it s-expression with its result.

#+BEGIN_SRC emacs-lisp
(defun eval-and-replace ()
  "Replace the preceding sexp with its value."
  (interactive)
  (backward-kill-sexp)
  (condition-case nil
      (prin1 (eval (read (current-kill 0)))
             (current-buffer))
    (error (message "Invalid expression")
           (insert (current-kill 0)))))

(defun eval-dwim (args)
  "If invoked with C-u then evaluate and replace the current expression, otherwise use regular `eval-last-sexp'"
  (interactive "P")
  (if args
      (eval-and-replace)
    (eval-last-sexp nil)))

(bind-keys :map emacs-lisp-mode-map
           ("C-x C-e" . eval-dwim))
#+END_SRC

*** Ruby Mode

#+BEGIN_SRC emacs-lisp
(use-package ruby-mode
  :mode "\\.rb\\'"
  :interpreter "ruby"
  :bind (:map ruby-mode-map
              ("<return>" . reindent-then-newline-and-indent))
  :config
  (setq ruby-indent-level 2
        ruby-insert-encoding-magic-comment nil)

  (add-to-list 'company-dabbrev-code-modes 'ruby-mode)

  ;; Highlight `&&' and `||' as a builtin ruby keywords
  (font-lock-add-keywords 'ruby-mode
                          '(("\\(&&\\|||\\)" . font-lock-builtin-face)))

  (use-package inf-ruby
    :commands (ruby-send-block-and-go ruby-send-region-and-go)
    :config
    (setq inf-ruby-default-implementation "pry")
    (add-hook 'ruby-mode-hook #'inf-ruby-minor-mode))

  (use-package rake
    :commands rake
    :config
    (setq rake-cache-file (concat my/history-dir "rake.cache")
          rake-completion-system 'ivy-read))

  (use-package bundler
    :commands bundle-install)

  (use-package rubocop
    :commands (rubocop-check-project rubocop-check-current-file)
    :bind (("C-c r <" . my/rubocop-check-project)
           ("C-c r , " . my/rubocop-check-current-file))))
#+END_SRC


Override =rubocop= functions so they automatically switch to the compilation buffer

#+BEGIN_SRC emacs-lisp
(defun my/rubocop-check-current-file ()
  (interactive)
  (rubocop-check-current-file)
  (popwin:select-popup-window))

(defun my/rubocop-check-project ()
  (interactive)
  (rubocop-check-project)
  (popwin:select-popup-window))
#+END_SRC

*** Setup rcodetools

rcodetools provide a way to evaulate ruby code inside your buffer. The way it works is you add ~# =>~ after an expression and then run ~xmp~ command and it will insert the result after the comment.

#+BEGIN_SRC emacs-lisp
(use-package rcodetools
  :ensure nil
  :commands xmp
  :bind (:map ruby-mode-map ("C-c C-c" . xmp)))

(defadvice my/comment-dwim (around rct-hack activate)
  "If comment-dwim is successively called, add => mark."
  (if (and (eq major-mode 'ruby-mode)
           (eq last-command 'my/comment-dwim))
      (progn (insert "=>")
             (xmp))
    ad-do-it))
#+END_SRC

*** Yasnippet

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :defer 1
  :config
  (add-hook 'snippet-mode-hook (lambda () (variable-pitch-mode nil)))
  (yas-global-mode))
#+END_SRC

*** SQL Mode

#+BEGIN_SRC emacs-lisp
(use-package sql
  :mode "\\.sql"
  :config
  (add-hook 'sql-interactive-mode-hook #'toggle-truncate-lines))
#+END_SRC

*** Rspec Mode

#+BEGIN_SRC emacs-lisp
(use-package rspec-mode
  :bind-keymap ("C-c C-," . rspec-mode-keymap)
  :config
  (setq rspec-compilation-skip-threshold 2
        rspec-snippets-fg-syntax 'concise
        rspec-use-spring-when-possible t
        rspec-use-bundler-when-possible t
        compilation-scroll-output t)

  (rspec-install-snippets)

  (add-hook 'rspec-compilation-mode-hook (lambda () (setq-local truncate-lines nil))))
#+END_SRC

*** Compilation Mode

#+BEGIN_SRC emacs-lisp
(add-hook 'compilation-mode-hook (lambda ()
                                   (toggle-truncate-lines 1)))
#+END_SRC

*** HAML mode

#+BEGIN_SRC emacs-lisp
(use-package haml-mode
  :ensure t
  :pin melpa-stable
  :defer t
  :config
  (progn
    (add-hook 'haml-mode-hook
              (lambda ()
                (rspec-mode)))
    (add-hook 'haml-mode-hook
              (lambda ()
                (local-set-key (kbd "RET") 'newline-and-indent)))))
#+END_SRC

*** Web Mode

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :defer t
  :pin melpa-stable
  :mode ("\\.html$" "\\.xml$" "\\.erb$" "\\.vue$")
  :config
  (progn
    (setq web-mode-css-indent-offset 2
          web-mode-markup-indent-offset 2
          web-mode-code-indent-offset 2
          web-mode-auto-close-style 2
          web-mode-enable-auto-pairing nil
          web-mode-script-padding 0)

    (add-hook 'web-mode-hook #'aggressive-indent-mode)
    (add-hook 'web-mode-hook #'subword-mode)))


#+END_SRC

*** YAML mode

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :ensure t
  :pin melpa-stable
  :defer t
  :config
  (progn
    (add-hook 'yaml-mode-hook
              (lambda ()
                (local-set-key (kbd "RET") 'newline-and-indent)))))
#+END_SRC

*** CSS Mode

#+BEGIN_SRC emacs-lisp
(add-hook 'css-mode-hook
          (lambda ()
                (setq comment-start "//")
                (setq comment-end "")
                (setq css-indent-offset 2)))
#+END_SRC

*** SCSS Mode

#+BEGIN_SRC emacs-lisp
#+END_SRC

*** Jinja Mode

I edit jinja files with names like =example.conf.j2= so I want Emacs to strip the =.j2= extension and choose the proper major mode

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.j2\\'" ignore t))
#+END_SRC

*** Coffeescript Mode

#+BEGIN_SRC emacs-lisp
(use-package coffee-mode
  :ensure t
  :pin melpa-stable
  :defer t
  :mode "\\.coffee\\.erb$"
  :config
  (progn
    (setq coffee-compile-jump-to-error nil
          coffee-tab-width 2)
    (add-hook 'coffee-mode-hook
              (lambda ()
                (rspec-mode)))))
#+END_SRC

*** Javascript Mode

#+BEGIN_SRC emacs-lisp
(add-hook 'js-mode-hook
          (lambda ()
            (setq js-indent-level 2)
            (subword-mode t)
            (aggressive-indent-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :ensure t
  :pin melpa-stable
  :defer t
  :mode ("\\.js$" "\\.json")
  :config
  (progn
    (setq js2-mode-show-parse-errors nil
          js2-mode-show-strict-warnings nil
          js2-mode-assume-strict t
          inferior-js-program-command "node"
          js2-basic-offset 2
          js2-bounce-indent-p t)
    (font-lock-add-keywords 'js2-mode
                            '(("require([^)]*)" . font-lock-builtin-face)))
    (set-face-attribute 'js2-function-param nil
                        :foreground nil
                        :inherit 'font-lock-constant-face)))

#+END_SRC

Add [[https://github.com/felipeochoa/rjsx-mode][rjsx-mode]] to handle jsx files

#+BEGIN_SRC emacs-lisp
(use-package rjsx-mode
  :config
  (progn
    (flycheck-add-mode 'javascript-eslint 'rjsx-mode)
    (flycheck-add-mode 'javascript-flow 'rjsx-mode)))
#+END_SRC

In =js2-mode= prettify symbols changes ~=>~, ~<=~, and ~>=~ to =⇒=, =≥=, and =≤= and I don't like that

#+BEGIN_SRC emacs-lisp
(add-hook 'js2-mode-hook (lambda () (setq prettify-symbols-alist nil)))
#+END_SRC

*** Java Mode

#+BEGIN_SRC emacs-lisp
(add-hook 'java-mode-hook #'subword-mode)
#+END_SRC

*** PHP mode

#+BEGIN_SRC emacs-lisp
(use-package php-mode
  :pin melpa-stable
  :ensure t
  :defer t)
#+END_SRC

*** Lua mode

#+BEGIN_SRC emacs-lisp
(use-package lua-mode
  :pin melpa-stable
  :ensure t
  :defer t
  :config
  (setq lua-indent-level 2)
  (add-hook 'lua-mode-hook #'subword-mode))
#+END_SRC

*** Elm mode

#+BEGIN_SRC emacs-lisp
(use-package elm-mode
  :pin melpa-stable
  :bind (("RET" . newline-and-indent))
  :config
  (add-to-list 'company-backends 'company-elm)
  (add-hook 'elm-mode-hook #'subword-mode))
#+END_SRC

*** Haskell mode

#+BEGIN_SRC emacs-lisp
(use-package haskell-mode
  :pin melpa-stable)
#+END_SRC

*** Swift mode

#+BEGIN_SRC emacs-lisp
(use-package swift-mode
  :pin melpa-stable
  :config
  (setq swift-mode:basic-offset 2)
  (add-hook 'swift-mode-hook (lambda () (subword-mode))))
#+END_SRC

** Misc Settings
*** OS X specific settings

#+BEGIN_SRC emacs-lisp
(setq ns-alternate-modifier 'super
      ns-command-modifier 'meta
      ns-control-modifier 'control)
#+END_SRC

**** OS X Arabic Keybaord

#+BEGIN_SRC emacs-lisp
(load "arabic-mac")
(setq default-input-method "arabic-mac")
#+END_SRC

**** Emoji

See my [[https://github.com/a3ammar/homebrew-emacs-emoji][homebrew formula]]

#+BEGIN_SRC emacs-lisp
(set-fontset-font t 'symbol (font-spec :family "Apple Color Emoji") nil 'prepend)
#+END_SRC

*** Incremenet/decrement numbers

#+BEGIN_SRC emacs-lisp
(use-package evil-numbers
  :pin melpa-stable
  :ensure t
  :bind (("M-=" . evil-numbers/inc-at-pt)
         ("M--" . evil-numbers/dec-at-pt)))
#+END_SRC

*** Focus help window on popup

#+BEGIN_SRC emacs-lisp
(setq help-window-select t)
#+END_SRC

*** Newline do what I mean

This I took from somewhere, it insert a space if I do =M-return= between bracket or
parentheses, etc.

#+BEGIN_SRC emacs-lisp
(defun my/newline-dwim ()
  (interactive)
  (let ((break-open-pair (or (and (looking-back "{ ?") (looking-at " ?}"))
                             (and (looking-back ">") (looking-at "<"))
                             (and (looking-back "(") (looking-at ")"))
                             (and (looking-back "\\[") (looking-at "\\]")))))
    (newline)
    (when break-open-pair
      (save-excursion
        (newline)
        (indent-for-tab-command)))
    (indent-for-tab-command)))

(bind-keys ("M-<return>" . my/newline-dwim))
#+END_SRC

*** Comment do what I mean

Better comments, taken from [[http://www.opensubscriber.com/message/emacs-devel@gnu.org/10971693.html][here]].

#+BEGIN_SRC emacs-lisp
(defun my/comment-dwim (&optional arg)
  "Replacement for the comment-dwim command.
 If no region is selected and current line is not blank and we are not at the end of the line, then comment current line.
 Replaces default behaviour of comment-dwim, when it inserts comment at the end of the line."
  (interactive "*P")
  (comment-normalize-vars)
  (if (and (not (region-active-p))
           (not (looking-at "[ \t]*$")))
      (comment-or-uncomment-region (line-beginning-position) (line-end-position))
    (comment-dwim arg)))

(bind-keys ("M-;" . my/comment-dwim))
#+END_SRC

*** Insert a brace with space between them

This I use when I'm programming Ruby to insert a block (blocks have a space between
the content the bracket).
With 5 as a prefix arguments =C-5 C-{=, it inserts a liquid tag ={%  %}=.

#+BEGIN_SRC emacs-lisp
(defun my/brace-with-space (&optional args)
  (interactive "p")
  (if (= args 5)
      (my/insert-liquid-tag)
    (my/insert-brace)))

(defun my/insert-brace ()
  (execute-kbd-macro "{")
  (insert "  ")
  (backward-char 1))

(defun my/insert-liquid-tag ()
  (execute-kbd-macro "{")
  (insert "%  %")
  (backward-char 2))

(bind-keys ("C-{" . my/brace-with-space))

#+END_SRC

*** Duplicate line

#+BEGIN_SRC emacs-lisp
(bind-keys ("C-x C-y" . my/duplicate-line))

(defun my/duplicate-line (&optional args)
  "duplicate the current line and while saving the current position"
  (interactive "P")
  (let ((column (current-column))
        (times (prefix-numeric-value args)))
        (while (> times 0)
          (move-beginning-of-line 1)
          (kill-line)
          (yank)
          (open-line 1)
          (next-line 1)
          (yank)
          (move-beginning-of-line 1)
          (forward-char column)
          (setq times (1- times)))))

#+END_SRC

*** Flip colon

#+BEGIN_SRC emacs-lisp
(bind-keys ("C-:" . my/flip-colons))

(defun my/flip-colons ()
  (interactive)
  (let ((word (thing-at-point 'sexp))
        (bounds (bounds-of-thing-at-point 'sexp)))
    (when (or (s-starts-with-p ":" word)
              (s-ends-with-p ":" word))
      (delete-region (car bounds) (cdr bounds))
      (if (s-starts-with-p ":" word)
          (insert (s-append ":" (s-chop-prefix ":" word)))
        (insert (s-prepend ":" (s-chop-suffix ":" word)))))))
#+END_SRC

*** Toggle inline braces { ... } to multiline

Toggle inline rule into multiline:

#+BEGIN_SRC css
// from this
h1 { font-size: 30px }

// into this
h1 {
  font-size: 30px;
}
#+END_SRC

#+BEGIN_SRC emacs-lisp
(bind-key "C-x t [" 'my/toggle-brace)

(defun my/toggle-brace ()
  (interactive)
  (let (start)
    (save-excursion
      (while (not (looking-back "{")) (backward-char))
      (setq start (point))
      (my/delete-or-insert-newline)
      (while (not (looking-at "\n? *}")) (forward-char))
      (my/delete-or-insert-newline)
      (indent-region start (line-end-position)))))

(defun my/delete-or-insert-newline ()
  (if (looking-at "\n")
      (progn
        (delete-char 1)
        (just-one-space))
    (insert "\n")))
#+END_SRC

*** Just one space to just no space

I use =just-one-space= all the time to forward delete all spaces, but almost always
what I want is delete all spaces to =point=

#+BEGIN_SRC emacs-lisp
(defun just-no-space ()
  (interactive)
  (re-search-forward "[ \t]+" nil t)
  (replace-match "" nil nil))

(bind-keys ("M-\\" . just-no-space))
#+END_SRC

*** Yank and delete from kill-ring

This is useful when you want to paste sensitive information and do not want it to stay in the =kill-ring= variable. Like pasting a password to =tramp=.

#+BEGIN_SRC emacs-lisp
(defun yank-and-remove-from-killring ()
  (interactive)
  (yank)
  (setq kill-ring
        (remove (first kill-ring) kill-ring)))

(bind-keys ("C-M-y" . yank-and-remove-from-killring))
#+END_SRC

*** Insert Arabic Tatweel Character

بعض الأحيان أحتاج أمـــــــــــد بعض الكلمات

#+BEGIN_SRC emacs-lisp
(defun my/insert-tatweel (arg)
  (interactive "P")
  (insert-char #x0640 arg))

(bind-keys ("C-x t _" . my/insert-tatweel))
#+END_SRC

*** Indent buffer

Taken from [[https://github.com/magnars/.emacs.d/blob/master/defuns/buffer-defuns.el#L144-166][Magnars' Emacs]]

#+BEGIN_SRC emacs-lisp
(defun indent-buffer ()
  (interactive)
  (indent-region (point-min) (point-max)))
#+END_SRC

*** Cleanup the buffer

Taken from [[https://github.com/magnars/.emacs.d/blob/master/defuns/buffer-defuns.el#L144-166][Magnars' Emacs]]

#+BEGIN_SRC emacs-lisp
(defun cleanup-buffer ()
  "Perform a bunch of operations on the whitespace content of a buffer.
Including indent-buffer, which should not be called automatically on save."
  (interactive)
  (untabify-buffer)
  (delete-trailing-whitespace)
  (indent-buffer))
#+END_SRC

*** Calculate expression and insert it

Useful for quick calculations, based on this reddit [[https://www.reddit.com/r/emacs/comments/445w6s/whats_some_small_thing_in_your_dotemacs_that_you/cznxx9f][post]].

#+BEGIN_SRC emacs-lisp
(defun my/calc-insert (arg)
  "Look for two numbers with a symbol between them and calculate their expression and replace them with the result"
  (interactive "p")
  (let (start end)
    (if (use-region-p)
        (setq start (region-beginning)
              end (region-end))
      (save-excursion
        (setq end (point))
        (setq start (search-backward-regexp "[0-9]+ ?[-+*/^] ?[0-9]+"
                                            (line-beginning-position) 1))))
    (let ((value (calc-eval (buffer-substring-no-properties start end))))
      (if (= arg 4)
          (message value)
        (delete-region start end)
        (insert value)))))

(bind-key "C-=" 'my/calc-insert)
#+END_SRC

*** Better =open-line=
I use =open-line= a lot and most of the time I have to manually indent the new line, lets fix this:

#+BEGIN_SRC emacs-lisp
(defun my/open-line (args)
  "Indent the new line after `open-line'"
  (interactive "p")
  (save-excursion
    (newline-and-indent))
  (indent-according-to-mode))

(bind-key "C-o" 'my/open-line)

#+END_SRC

*** Embrace mode
[[https://github.com/cute-jumper/embrace.el][Embrace mode]] makes surrounding words with pairs so easy

#+BEGIN_SRC emacs-lisp
(use-package embrace
  :ensure t
  :bind (("C-'" . embrace-change)))
#+END_SRC

*** Better keybinding for =revert-buffer=

No one likes =s-u=

#+BEGIN_SRC emacs-lisp
(bind-key "C-x t r" 'revert-buffer)
#+END_SRC

* Load my secrets

These are stuff I dont' want to commit to a public repo

#+BEGIN_SRC emacs-lisp
(load "~/.emacs.secrets" t)
#+END_SRC
